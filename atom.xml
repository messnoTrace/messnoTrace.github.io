<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>your will my hands</title>
  <icon>https://www.gravatar.com/avatar/587c2c7ccce52cc68f731e598f32b75c</icon>
  <subtitle>your will my hands</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://messnoTrace.github.io/"/>
  <updated>2019-04-05T03:44:17.199Z</updated>
  <id>https://messnoTrace.github.io/</id>
  
  <author>
    <name>乱逃</name>
    <email>messnoTrace@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 多渠道打包修改app name，icon</title>
    <link href="https://messnoTrace.github.io/2019/04/05/Android-%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E4%BF%AE%E6%94%B9app-name%EF%BC%8Cicon/"/>
    <id>https://messnoTrace.github.io/2019/04/05/Android-多渠道打包修改app-name，icon/</id>
    <published>2019-04-05T03:44:02.000Z</published>
    <updated>2019-04-05T03:44:17.199Z</updated>
    
    <content type="html"><![CDATA[<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  </p><p><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  </p><p><script>hljs.initHighlightingOnLoad();</script><br>搞过多渠道打包的都知道，我们只需要在 module 的build.gradle中配置相应的渠道号就行:</p><pre><code>productFlavor{          baidu {          }        xiaomi{}         wandoujia{}    }</code></pre><p>像这样，就可以了，然后将友盟的chanelvalue修改下就可以了，需要不同的渠道，配置不同的applicationid，也不是什么难事。不过今天我遇到的需求是，不同的渠道配置不同的appname和icon。一开始我想着用之前的哪种方法应该可行，然后就试了下，一试不知道，试过就蛋疼了，appname是可以换掉，但是icon呢，，咋整，，，找了一圈方法，都木有找到，郁闷，string类型的，都可以通过常用的那种替换占位符的方式来改，或者是resValue(这个没有试，，但是似乎是可以的)。然后各种搜资料，有什么设置 useOldManifestMerger false ，不过自己没试成功（不能怪我，理论是这个道理的，只不过gradle版本不一样，Google升级了，导致我懵逼了）偶然间Google了一下  how to change app icon for diffrent productFlavors in android，点开第一个<a href="http://stackoverflow.com/questions/22875948/how-to-provide-different-android-app-icons-for-different-gradle-buildtypes" target="_blank" rel="external">链接</a>,然后答主的答案给了我一些启发：</p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-3cbf6c005c8c592c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160811184619.png"></p><p>然后搜啊搜，又找到了<a href="http://stackoverflow.com/questions/25981156/tools-replace-not-replacing-in-android-manifest" target="_blank" rel="external">这个</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-0c8656280ca0a302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160811185123.png"></p><p>然后经过自己的摸索，搞了出来了，简单来说：<br>大家看第一张图你的目录结构就会发现，如果我们在src/main/文件夹下新建以我们去渠道名为名的，目录结构和main一样的文件目录，当我们打包的时候就会读取这里面的资源文件，所以呢，我就新建了个清单文件，将头部换成图二所示，在根目录添加</p><pre><code>xmlns:tools=&quot;http://schemas.android.com/tools&quot;</code></pre><p>然后application</p><pre><code>tools:replace=&quot;android:icon&quot; android:icon=&quot;@drawable/icon_all&quot;</code></pre><p>替换你需要换的icon就行，ok，至此搞定，至于为什么这么搞，我看到了官方的一篇文章<a href="http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger#TOC-Manifest-files-ordering" target="_blank" rel="external">清单合并</a>,另外还有篇国内<a href="http://blog.csdn.net/maosidiaoxian/article/details/42671999" target="_blank" rel="external">译文</a></p><p>剩下的就靠小伙伴么自己摸索了。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;http://cdn.bo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AndroidStudio中调用.so包出现找不到.so包的错误</title>
    <link href="https://messnoTrace.github.io/2019/04/05/AndroidStudio%E4%B8%AD%E8%B0%83%E7%94%A8-so%E5%8C%85%E5%87%BA%E7%8E%B0%E6%89%BE%E4%B8%8D%E5%88%B0-so%E5%8C%85%E7%9A%84%E9%94%99%E8%AF%AF/"/>
    <id>https://messnoTrace.github.io/2019/04/05/AndroidStudio中调用-so包出现找不到-so包的错误/</id>
    <published>2019-04-05T03:40:45.000Z</published>
    <updated>2019-04-05T03:42:05.763Z</updated>
    
    <content type="html"><![CDATA[<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  </p><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  <script>hljs.initHighlightingOnLoad();</script>  <p><img src="http://upload-images.jianshu.io/upload_images/1453857-0fb31dfbb366a918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160721125018.png"></p><p>###出现原因<br>RT,在Andoridsutdio中调用.so库出现如现标题所示错误，该怎么解决。首先出现这个错误的原因是因为你的cpu架构是64位的。而你的.so库在编译的时候没有支持64位cpu。<strong>  如果这个.so的库是你自己弄的，那你重新生成下支持64位cpu的.so库出来就行了，剩下的文字就不用看了，本文适用于你没法对.so做操作的朋友。</strong> 查看cpu架构，可以通过adb shell 命令。进入/system/目录下有一个build.prop文件，这个里面有一行 ro.product.cpu.abi=xx就是你所要的信息，具体命令如下:</p><pre><code>adb shellcd /systemcat build.prop</code></pre><p>apk包在安装的时候，系统会把包中与自己的abi对应的lib目录中的so库文件拷贝到system分区中，32位机器中只有一个目录/system/lib，64位机器中有两个目录/system/lib和/system/lib64，app启动进行链接时，64位机器中会先到/system/lib64目录中去找，这时候肯定找不到。如果没有找到再到/system/lib目录中去找。如果你把32位的so库拷贝到了lib64目录中，会导致链接失败，同样，64位的so库被拷贝到lib目录中也会导致失败，所以so库要和目录一一对应。</p><p>###解决方案<br>首先我的目录结构是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/1453857-be5473a00f8f04a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160721123538.png"><br>我的.so并没有放在新建的jniLibs目录中，这个关系应该不大，两种方式都可以。<br>我的cpu架构是 ro.product.cpu.abi=arm64-v8a<br>而我的只有一个CPU架构就是armebi-v7a,我们要做的就是阻止生成arm64-v8a;<br>正常情况打开apk的lib结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/1453857-5e5183dd73f1ac09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160721124748.png"></p><p>方案如下：</p><ul><li>首先在project目录下的 gradle.properties中添加一句 <pre><code>android.useDeprecatedNdk=true</code></pre></li><li>在app的build.gradle中的defaulConfig下添加如下：<pre><code>ndk {    abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot;, &quot;mips&quot;}</code></pre></li></ul><p>这时候你解压开生成的apk包，会发现目录lib结构如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-df30fc0704288587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160721124539.png"></p><p>OK，这样就解决了我的这个问题，网络上有一些别的阻止生成arm64-v8a，但是不好使。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;http://cdn.bootc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android通过反射实现静默安装</title>
    <link href="https://messnoTrace.github.io/2019/04/05/Android%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85/"/>
    <id>https://messnoTrace.github.io/2019/04/05/Android通过反射实现静默安装/</id>
    <published>2019-04-05T03:38:23.000Z</published>
    <updated>2019-04-05T03:39:02.253Z</updated>
    
    <content type="html"><![CDATA[<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  </p><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  <script>hljs.initHighlightingOnLoad();</script>  <p>本文讲解通过反射Android pm  instal来调用隐藏api， 来静默安装，至于原理什么的，就不多说了，网络上一搜一大把，下面是亲测可行的；<br>先上<a href="https://github.com/messnoTrace/SlienceInstall" target="_blank" rel="external">Demo</a>,其中的libs文件夹下的class.jar是主角。<br>本文有一个大前提，那就是你的apk是放在系统/system/priv-app目录下，也就是说，rom是你们自己搞的，手动滑稽=。=<br>如果你是用AndroidStudio版本的，也是链接中的<a href="https://github.com/messnoTrace/SlienceInstall/tree/master/DemoSilenceInstall" target="_blank" rel="external">DemoSilenceInstall</a><br>步骤如下：</p><ul><li>建一个你自己的工程 ，将class.jar放入到libs目录下。</li><li>然后projectStructure(按F4直接进)，进入dependence点击+号，选择FileDependence 记得把 scope置为Provided，如下图:<br><img src="http://upload-images.jianshu.io/upload_images/1453857-d74f2be33a1b022c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></li></ul><ul><li><p>工程目录下的gradle文件修改：</p><pre><code>allprojects {    repositories {                  jcenter()            }              gradle.projectsEvaluated {                                  tasks.withType(JavaCompile) {                                        options.compilerArgs.add(&apos;-Xbootclasspath/p:app\\libs\\class.jar&apos;)                                    }                   }            }</code></pre><p>   <strong>看好名字,不要眼瞎，后面是你起的jar包的名字，这个名字随意取，两者对应就行，</strong></p><p>  以上的操作的目的有两个：</p><pre><code>1.就是将class.jar以eclipse中那种userlib的形式导入，2.调整jar包的优先级</code></pre></li><li>再将demo中install 包下的代码放到你的工程中.如果这个时候你的PM.java这个文件不报错，那么恭喜，你的操作就算完成了</li><li>这个步骤我的代码出现了问题，不知道你的会不会，就是Android中65535问题了，也就是解决这个问题做的操作，AS下好解决，这个不做过多解释。</li></ul><p>剩下的，就是将应用打包签名，放到/system/priv-app这个目录下 就ok了，</p><p>下面说下Eclipse版本的操作，代码都是一样的，jar包也是一样，就两点，jar包通过userlibrary的形式导入，直接放图吧，多图慎入：<br><img src="http://upload-images.jianshu.io/upload_images/1453857-e9e8d436fbd4ddde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="![Uploading 4_049957.png . . .]"></p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-d5b134f0db69b9a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-cecd54290fd90360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><p>![</p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-e6cde6675deb959b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Uploading 6_086779.png . . .]"></p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-16490fdfd7ab0de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-73ac54c47095b33b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-c524e6d1cb374503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-c57017127dc439c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-d0b9e66477c90d60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="![Uploading 10_162291.png . . .]"></p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-8fd7af66b59e3784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.png"></p><p>至此，，搞定了，╮(╯▽╰)╭，继续搬砖。如果你要问这个class怎么来的，你找做rom的大神们给你编译一份源码就行，反正我不会。OTZ…. 然而这个地方在我写完文章后又出现了一个实战问题，那就是用multydex分包处理后，还是会出现 <a href="http://stackoverflow.com/questions/32721083/too-many-classes-in-main-dex-list-main-dex-capacity-exceeded" target="_blank" rel="external">Too many classes in –main-dex-list, main dex capacity exceeded</a>，，目前一个最简单暴力的方法就是把minsdkversion 调成21+，我在想想办法，，，，解决了更新文章。</p><p>(⊙o⊙)…，暂时没解决，不过上了一个新版本，用aidl实现的，也是可以用<a href="https://github.com/messnoTrace/SlienceInstall/tree/master/MyApplication" target="_blank" rel="external">这里的</a>…东西都差不多，jar包换了个精简的，然后改用aidl实现的注意，aidl的包名不要动，，，然后配置下gradle里面的aidl</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;http://cdn.bootc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android修改CheckBoxPreference 中title ，summary字体的颜色</title>
    <link href="https://messnoTrace.github.io/2019/04/05/Android%E4%BF%AE%E6%94%B9CheckBoxPreference-%E4%B8%ADtitle-%EF%BC%8Csummary%E5%AD%97%E4%BD%93%E7%9A%84%E9%A2%9C%E8%89%B2/"/>
    <id>https://messnoTrace.github.io/2019/04/05/Android修改CheckBoxPreference-中title-，summary字体的颜色/</id>
    <published>2019-04-05T03:36:23.000Z</published>
    <updated>2019-04-05T03:36:57.633Z</updated>
    
    <content type="html"><![CDATA[<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  </p><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  <script>hljs.initHighlightingOnLoad();</script>  <p>以前没怎么关注过PreferenceActivity的一些用法只是简单了解下，然后刚好今天遇到了某个机型上出现了问题：<strong>我明明设置的是黑色的字体，在这个机器上却是白色的</strong>，然后各种摸索得出了个推论，页面的字体颜色什么的，可能是更随系统来的，受系统调控：<br>我是这么写的，</p><pre><code>  &lt;CheckBoxPreference      android:defaultValue=&quot;true&quot;    android:key=&quot;weather_use_metric&quot;  android:textColor=&quot;@color/black&quot;  android:title=&quot;@string/weather_use_metric&quot; /&gt;</code></pre><p>问题出现 了那没办法，只能想办法改了，好在现在学会了面向google编程，然后搜的一下，找到了个解决方案，先上怎么解决，然后再说为什么这么干。首先建个layout ，名字随便取（我取名custom_preferece_layout.xml），内容如下:</p><pre><code>          &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;              android:layout_width=&quot;match_parent&quot;           android:layout_height=&quot;wrap_content&quot;              android:minHeight=&quot;?android:attr/listPreferredItemHeight&quot;            android:gravity=&quot;center_vertical&quot;            android:paddingRight=&quot;?android:attr/scrollbarSize&quot;&gt;          &lt;RelativeLayout android:layout_width=&quot;wrap_content&quot;                  android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;15dip&quot;            android:layout_marginRight=&quot;6dip&quot;         android:layout_marginTop=&quot;6dip&quot;               android:layout_marginBottom=&quot;6dip&quot;          android:layout_weight=&quot;1&quot;&gt;             &lt;TextView android:id=&quot;@+android:id/title&quot;                  android:layout_width=&quot;wrap_content&quot;          android:layout_height=&quot;wrap_content&quot;                  android:singleLine=&quot;true&quot;           android:textAppearance=&quot;?android:attr/textAppearanceLarge&quot;                  android:ellipsize=&quot;marquee&quot; android:fadingEdge=&quot;horizontal&quot;                  android:textColor=&quot;@color/black&quot; /&gt;            &lt;TextView android:id=&quot;@+android:id/summary&quot;              android:layout_width=&quot;wrap_content&quot;         android:layout_height=&quot;wrap_content&quot;                  android:layout_below=&quot;@android:id/title&quot;         android:layout_alignLeft=&quot;@android:id/title&quot;                  android:textAppearance=&quot;?android:attr/textAppearanceSmall&quot;               android:maxLines=&quot;4&quot; /&gt;      &lt;/RelativeLayout&gt;    &lt;!-- Preference should place its actual preference widget here. --&gt;      &lt;LinearLayout android:id=&quot;@+android:id/widget_frame&quot;            android:layout_width=&quot;wrap_content&quot;       android:layout_height=&quot;match_parent&quot;              android:gravity=&quot;center_vertical&quot; android:orientation=&quot;vertical&quot; /&gt;  &lt;/LinearLayout&gt;</code></pre><p>在这个布局中修改title，sunmmary的颜色就可以了。<br>然后再CheckBoxPreference    中加一句：</p><pre><code>&lt;CheckBoxPreference    android:defaultValue=&quot;true&quot;      android:key=&quot;weather_use_metric&quot;    android:layout=&quot;@layout/custom_preferece_layout&quot;   android:textColor=&quot;@color/black&quot;        /&gt;</code></pre><p>然后，就解决了这个问题，那为什么这么搞呢？进入CheckBoxPreference   顶层父类Preference中看，看到构造中的注释了：</p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-fca483c577435efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20161110175559.png"></p><p>这玩意默认的控制了样式，然后再往下看到一个方法：</p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-54f7fd8444a953dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20161110175911.png"></p><p>他说大部分情况足够用了，但是这不是出来问题么，于是到android的values中的attr下找，</p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-e5a69f67b3b10c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>嗯很贴心，行数都截出来了。顶层默认实现了个布局，在CheckBoxPreference的onBindView方法中出现了个id和一个方法：<br><img src="http://upload-images.jianshu.io/upload_images/1453857-30381fbc2e2d3ff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20161110181103.png"></p><p>id点进去能找到个布局，然后再父类TwoStatePreference中可以看到这个方法里面写了什么，注意看上面的布局控件的id，你没看错，就是覆盖了preference_material.xml 中的布局：</p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-c2fb7896c6189aba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20161110181315.png"></p><p>附上答案链接 <a href="http://stackoverflow.com/questions/4469514/how-to-customize-text-color-of-the-checkboxpreference-title" target="_blank" rel="external">http://stackoverflow.com/questions/4469514/how-to-customize-text-color-of-the-checkboxpreference-title</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;http://cdn.bootc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android Accessbility的简单用法</title>
    <link href="https://messnoTrace.github.io/2019/04/05/Android-Accessbility%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95/"/>
    <id>https://messnoTrace.github.io/2019/04/05/Android-Accessbility的简单用法/</id>
    <published>2019-04-05T03:33:38.000Z</published>
    <updated>2019-04-05T03:33:55.431Z</updated>
    
    <content type="html"><![CDATA[<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  </p><p><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  </p><p><script>hljs.initHighlightingOnLoad();</script><br>Accessbility 又叫做辅助功能，是Android官方推出帮助身体不便或者操作不灵活的人来辅助操作的，也可以用来干一些别的事，比如自动抢红包啊，静默安装点击啊等已知或者未知的应用。出于某种需求，就研究了下这个功能的简单用法，先做一个模拟按钮点击的效果。<br>  布局很简单，就不贴代码了，简单描述下，主界面就一个按钮，id随便你取，在Activity中设置点击事件，弹出一个Toast。</p><p>#####步骤</p><ol><li><p>创建CheckAccessbilityServices：<br>CheckAccessbilityServices 继承自AccessibilityService，并在清单文件applcation节点中配置，并加入权限</p><pre><code>&lt;service    android:name=&quot;.CheckAccessbilityServices&quot;    android:enabled=&quot;true&quot;        android:exported=&quot;true&quot;android:label=&quot;测试点击&quot;android:permission=&quot;android.permission.BIND_ACCESSIBILITY_SERVICE&quot;&gt;      &lt;intent-filter&gt;            &lt;action android:name=&quot;android.accessibilityservice.AccessibilityService&quot; /&gt;      &lt;/intent-filter&gt;    &lt;meta-data         android:name=&quot;android.accessibilityservice&quot;         android:resource=&quot;@xml/check_accessibility_config&quot; /&gt;&lt;/service&gt;&apos;</code></pre><p>2.在res目录下创建文件夹xml，并创建步骤一中check_accessibility_config.xml</p><pre><code>&lt;accessibility-service xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;                   android:description=&quot;@string/check_click&quot;     android:packageNames=&quot;com.notrace&quot;      android:accessibilityEventTypes=    &quot;typeAllMask|typeViewClicked|typeViewFocused|typeNotificationStateChanged|typeWindowStateChanged&quot;      android:accessibilityFlags=&quot;flagDefault&quot;     android:accessibilityFeedbackType=&quot;feedbackSpoken&quot;      android:notificationTimeout=&quot;100&quot;     android:canRetrieveWindowContent=&quot;true&quot;    /&gt;</code></pre><p>这里面有一些常用的属性，简单介绍下</p><pre><code>android:accessibilityEventTypes=&quot;typeAllMask&quot;</code></pre><p>看属性名也差不多可以明白，这个是用来设置响应事件的类型，typeAllMask当然就是响应所有类型的事件了。当然还有单击、长按、滑动等。 </p><pre><code>android:accessibilityFeedbackType=&quot;feedbackSpoken&quot;</code></pre><p>设置回馈给用户的方式</p><pre><code>android:notificationTimeout=&quot;100&quot;</code></pre><p>响应时间的设置就不用多说了 </p><pre><code>android:packageNames=&quot;com.notrace&quot;</code></pre><p>可以指定响应某个应用的事件，我的demo包名就叫com.notrace,可以多个，用”,”隔开。</p><pre><code>android:description=&quot;模拟点击&quot;</code></pre></li></ol><p>描述你在系统辅助功能开关中看到的描述</p><p>3.CheckAccessbilityServices  实现onAccessibilityEvent和onInterrupt方法</p><pre><code>     @Override   public void onAccessibilityEvent(AccessibilityEvent event) {             //过滤包名         String pkgName = event.getPackageName().toString();             if(!&quot;com.notrace&quot;.equals(pkgName))                 return;         switch (type){                 case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:                 //切换页面的时候此时会触发一个叫TYPE_WINDOW_STATE_CHANGED的事件             AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();             if(nodeInfo!=null)  {                if(&quot;com.notrace.MainActivity&quot;.equals(event.getClassName())){                         List&lt;AccessibilityNodeInfo&gt;     list=                     nodeInfo.findAccessibilityNodeInfosByViewId(&quot;com.notrace:id/btn_click&quot;);               if(list!=null&amp;&amp;list.size()&gt;0)  {                       list.get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);                       }                   }                   break;           case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:             break;       }                     }  </code></pre><p>注意这里有个叫com.notrace:id/btn_click的，就是前面的那个按钮，我取id叫btn_click,这个东西可以通过eclipse提供的一个工具dump查看,如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1453857-78fa62630f5370b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160808162014.png"></p><p>微信抢红包的界面你就可以这么看了。<br>list.get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);      就是模拟点击事件</p><p>至此，模拟点击就已经全部完成了，我们打开手机辅助功能界面会看见：<br><img src="http://upload-images.jianshu.io/upload_images/1453857-2b1084259b04dab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160808162331.png"><br>点击进去：<br><img src="http://upload-images.jianshu.io/upload_images/1453857-cd8e0447e512c2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ截图20160808162434.png"></p><p>打开这个开关就可以了。<br>至此，当页面切换到MainActivity中就可以弹出toast了，至于别的奇奇怪怪的功能，就需要小伙伴们自己摸索了。<br><a href="https://github.com/messnoTrace/Demo_Accessbility.git" target="_blank" rel="external">Demo代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;http://cdn.bo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android room 存储复杂数据类型</title>
    <link href="https://messnoTrace.github.io/2019/04/05/android-room-%E5%AD%98%E5%82%A8%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://messnoTrace.github.io/2019/04/05/android-room-存储复杂数据类型/</id>
    <published>2019-04-05T03:21:13.000Z</published>
    <updated>2019-04-05T03:51:02.920Z</updated>
    
    <content type="html"><![CDATA[<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  </p><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  <script>hljs.initHighlightingOnLoad();</script>  <p>首先看此文章的都假设你已经看过了room的简单用法，如果没有看过，那你可能需要先去看看了。<br>假设，我们从后台返回一个数据类型是这样的：    </p><pre><code>    public class News{      public long id;      public String title;      public String title;      public List&lt;Tag&gt;tags;    }  public class Tag{    public long id;    public String name;}</code></pre><p>这种数据类型就比较很常见了，当然了，你第一反应可能是： 这个哪里复杂了，嗯，说不复杂确实不复杂，说复杂呢，是因为用room的话，确实比较麻烦，说白了，就是如何用 room存储带有lis<object>类型的数据。ok话不多说，我们直接上代码：</object></p><p>###bean的改造</p><pre><code>@Entity(tableName = &quot;news&quot;) public class News{@PrimaryKey(autoGenerate = true)  public long id;  public String title;  public String title; @Ignore  public List&lt;Tag&gt;tags;}  @Entity(tableName = &quot;tags&quot;) public class Tag{       @PrimaryKey(autoGenerate = true)        public long id;        public String name;         @ColumnInfo(name = &quot;news_id&quot;)      public long newsid;  }</code></pre><p>然后我们重新添加一个bean：NewsWithTags:</p><pre><code>public class NewsWithTags{@Embeddedpublic News news;  @Relation(parentColumn = &quot;id&quot;,entityColumn = &quot;news_id&quot;)   public List&lt;Tag&gt; tags;    }</code></pre><p>注意看这个bean，没有table注解@Embedded 注解的是news这个bean。<br>@Relation 中parentColumn对应的是news中的id，entityColumn对应的是tag中的news_id,这个值实际上就等于news中的id。</p><p>####Dao<br>    NewsWithTagDao:</p><pre><code> @Daopublic interface NewsWithTaDao {@Transaction@Query(&quot;SELECT * FROM news&quot;)List&lt;NewsWithTag&gt; getAllNews();}</code></pre><blockquote><p>其他没啥好说的，添加数据要先添加news，然后根据news 的id添加tag，删除数据，要先根据news的id删除tag表中的数据</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;http://cdn.bootc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Unable to resolve dependency for xxCould not resolve library的解决方案</title>
    <link href="https://messnoTrace.github.io/2019/04/05/%E5%85%B3%E4%BA%8EUnable%20to%20resolve%20dependency%20for%20xxCould%20not%20resolve%20library%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://messnoTrace.github.io/2019/04/05/关于Unable to resolve dependency for xxCould not resolve library的解决方案/</id>
    <published>2019-04-05T02:39:39.000Z</published>
    <updated>2019-04-05T03:48:32.413Z</updated>
    
    <content type="html"><![CDATA[<p>先介绍下背景，环境是Androidstudio3.1.3，没错，截止目前是最新的，在不久之前，我用的是3.1.2，然后新建项目，敲上代码，implemention 各种顺手的library，毛问题都没有，升级了3.1.3之后，我想加一个库，结果出现了如下的各种问题。<img src="https://upload-images.jianshu.io/upload_images/1453857-4489eca9ee9892f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180626-110232.png"></p><p>一开始我以为是库的问题，然后一顿google搜索：<br><img src="https://upload-images.jianshu.io/upload_images/1453857-b767224e5beb26ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180626-110400@2x.png"></p><p>眼睛一亮，看到第二个答案直接出现关键词androidstudio3.0，心里顿时一阵鸡冻，点进去看看答案，直接找认同最多的答案：<br><img src="https://upload-images.jianshu.io/upload_images/1453857-2d2ff13fcdfab998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180626-110636@2x.png"></p><p>意思是啥呢，大概就是说在andoridsutio2.x向3.x迁移的时候需要注意修改的东西，然并卵啊，我是直接上的3.X的新项目，没有迁移一说。随后又是一阵搜索，这下就尴尬了，答案基本上都是类似这样 的和不勾选gradle offline work这个选项，各种搜索各种的贼鸡儿蛋疼，年轻人你感觉得到绝望么，我在想，如果时光可以倒流，我肯定不手贱升级AndroidStudio，以前的2.x用起来，是毛问题都没有啊，google都救不了我了，我怕是没救了，绝望。添加不了任何库，这个问题，是真的真的很蛋疼啊，啥都要自己写，换你，你愿意么？反正我是不愿意。。<br>接着又是一波操作猛如虎，中间过程就不重要了，直接跳结果吧。<br>打开Terminal选项卡，输入 ./gradlew build（windows下是gradlew build提示没这个命令的，那就是你的gradle环境变量没配置）-&gt; 回车</p><p><img src="https://upload-images.jianshu.io/upload_images/1453857-6a68fddb44522e5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180626-111908.png"></p><p>重点来了，<code>Connect to 127.0.0.1:1080 [/127.0.0.1] failed: Connection refused (Connection refused)</code> mmp 搜索：<br><img src="https://upload-images.jianshu.io/upload_images/1453857-e4706390e41dfdf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180626-112122@2x.png"></p><p>第一个点进去 <a href="https://blog.csdn.net/Rainminism/article/details/79713788" target="_blank" rel="external">链接</a><br>进去一看说我们使用了代理，要修改gradle.properties 文件，然后默默的打开我们的工程此文件一看，<img src="https://upload-images.jianshu.io/upload_images/1453857-23b4e09470d702f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180626-112620.png"></p><p>意不意外，惊不惊喜，里面毛都没有啊，然后有没有人跟我一样，有点怀疑人生了，怎么办怎么办，继续搜索啊，果然，在一个答案中发现了自己是有多傻逼<br><img src="https://upload-images.jianshu.io/upload_images/1453857-f646707a7e7906d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180626-113000@2x.png"></p><p>重点来了，第一句，<code>Go to gradle scripts</code> ，卧槽，我想起来个东西，我们通常用的都是project视图啊，新建项目都是Android视图啊，要是你曾经看过Andorid视图，或者说你曾经解决过Andoridstudio遇到的坑，那你就明白了我说的是啥，吓得我赶紧切换到Android视图：<br><img src="https://upload-images.jianshu.io/upload_images/1453857-834fb634600acea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180626-113441.png"></p><p>果然，<code>globle properties</code><br>打开一看，mmp，果然存在：<img src="https://upload-images.jianshu.io/upload_images/1453857-5b2fc6c929a87506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20180626-113550.png"><br>果断注释，重新编译，老铁，真的没毛病了。😌 mmp</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先介绍下背景，环境是Androidstudio3.1.3，没错，截止目前是最新的，在不久之前，我用的是3.1.2，然后新建项目，敲上代码，implemention 各种顺手的library，毛问题都没有，升级了3.1.3之后，我想加一个库，结果出现了如下的各种问题。&lt;img
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>多线程中wait/notify的一些理解，以及最经典的生产者和消费者</title>
    <link href="https://messnoTrace.github.io/2019/04/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%ADwait-notify%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%9C%80%E7%BB%8F%E5%85%B8%E7%9A%84%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>https://messnoTrace.github.io/2019/04/05/多线程中wait-notify的一些理解，以及最经典的生产者和消费者/</id>
    <published>2019-04-05T02:37:28.000Z</published>
    <updated>2019-04-05T03:51:44.996Z</updated>
    
    <content type="html"><![CDATA[<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  </p><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  <script>hljs.initHighlightingOnLoad();</script>  <p>###前言<br>说到wait，很容易想到一个常问的面试题，wait和sleep的区别。简单的理解就是，wait是object的方法，调用wait()，线程会进去等待状态，并且会释放出锁，非阻塞的，等待持有锁的线程调用notify()，才会继续执行。sleep是Thread的方法，sleep()会让当前线程暂停一段时间，但是不会释放锁，是阻塞的。</p><p>###Wait/notify在线程中的通信<br>我们先看下面一段代码：<br> class Data:</p><pre><code>      package com.notrace;      import java.util.ArrayList;      import java.util.List;      public class Data {  private List list=new ArrayList();    public void add() {      list.add(&quot;notrace&quot;);  }    public int getSize() {  return list.size();  }}</code></pre><p>ThreadA：</p><pre><code>  package com.notrace;       public class ThreadA extends Thread{ private Data data; public ThreadA(Data data) {    super();    this.data=data;}@Overridepublic void run() {    try {        for (int i = 0; i &lt; 10; i++) {            data.add();            System.out.println(&quot;添加了&quot;+(i+1)+&quot;个元素&quot;);            Thread.sleep(1000);        }    } catch (Exception e) {    }}     }</code></pre><p>ThreadB:</p><pre><code>package com.notrace;public class ThreadB extends Thread{private Data data;public ThreadB(Data data) {    super();    this.data=data;}@Overridepublic void run() {    try {        while (true) {    System.out.print(&quot;&quot;);            if(data.getSize()==6) {                System.out.println(&quot;==6,线程B要退出了&quot;);                throw new InterruptedException();            }        }    } catch (Exception e) {        e.printStackTrace();    }}}</code></pre><p>Test:</p><pre><code>  package com.notrace;public class Test {public static  void  main(String []args) {    Data data=new Data();    ThreadA threadA=new ThreadA(data);    threadA.setName(&quot;A&quot;);    threadA.start();    ThreadB threadB=new ThreadB(data);    threadB.setName(&quot;B&quot;);    threadB.start();}}</code></pre><p>运行test，结果如下：<img src="https://upload-images.jianshu.io/upload_images/1453857-21d6e937cb766da6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p><p>两个线程之间实现了通信，但是有一个弊端，就是线程B，要不停的循环，这样会很浪费资源，那么有没有什么好的办法去实现多个线程通信呢，答案是肯定的，就是wait/notify的机制。</p><p>###wait/notify机制简单介绍<br>举个栗子，就说我们日常生活中的餐厅吧，厨师和服务员之间的交互，<br>厨师做完菜，放到传递台上，服务员来传递台上取，往桌上送。<br> 1）厨师做完一道菜的时间是不确定的，所以把菜放到传递台上的时间也是不确定的。<br>2）服务员取菜的时间，取决于厨师，所以，厨师做完菜之前，服务员，就有了等待(wait)的状态。<br>3）服务员是怎么取到菜呢？这取决于厨师，简单点来说，厨师做完菜，放到传递台上，然后大喊一声：“红烧肉好了，来上菜。”然后服务员就过来取了，这个大喊一声，就相当于notify的过程。<br>4）这个情景中就有wait/notify的机制了，那么如何用代码来实现呢？</p><p>####wait/notify机制简单实现<br>方法wait（）的作用是使当前执行代码的线程进行等待，wait（）方法是Object类的方法，该方法用来将当前线程置入“预执行队列”中，并且在wait（）所在的代码行处停止执行，直到接到通知或被中断为止。在调用wait（）之前，<strong>线程必须获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法。在执行wait（）方法后，当前线程释放锁。</strong> 在从wait（）返回前，线程与其他线程竞争重新获得锁。如果调用wait（）时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕捉异常。<br><strong>方法notify（）也要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁。如果调用notify（）时没有持有适当的锁，也会抛出IllegalMonitorStateException。</strong>该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选出其中一个呈wait状态的线程，对其发出通知notify，并使它等待获取该对象的对象锁。需要说明的是，在执行notify（）方法后，当前线程不会马上释放该对象锁，呈wait状态的线程也并不能马上获取该对象锁，要等到执行notify（）方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁，而呈wait状态所在的线程才可以获取该对象锁。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。<br>   用一句话来总结一下wait和notify：wait使线程停止运行，而notify使停止的线程继续运行。<br>代码测试如下：<br>ThreadA:</p><pre><code>      package com.notrace;public class ThreadA extends Thread {private Object lock;public ThreadA(Object lock) {    super();    this.lock = lock;}@Overridepublic void run() {    try {        synchronized (lock) {            System.out.println(&quot;begin wait time&quot; +       System.currentTimeMillis());            lock.wait();            System.out.println(&quot;end wait time&quot; + System.currentTimeMillis());        }    } catch (Exception e) {        e.printStackTrace();    }}}</code></pre><p>ThreadB:</p><pre><code>        package com.notrace;public class ThreadB extends Thread {private Object lock;public ThreadB(Object lock) {    super();    this.lock = lock;}@Overridepublic void run() {    try {        synchronized (lock) {            System.out.println(&quot;begin notify time:&quot; + System.currentTimeMillis());            lock.notify();            System.out.println(&quot;end nofity time:&quot; + System.currentTimeMillis());        }    } catch (Exception e) {        e.printStackTrace();        System.out.println(e.toString());    }}}</code></pre><p>Test:</p><pre><code>package com.notrace;</code></pre><p>public class Test {<br>    public static void main(String[] args) {</p><pre><code>    try {        Object lock = new Object();        ThreadA threadA = new ThreadA(lock);        threadA.setName(&quot;A&quot;);        threadA.start();        Thread.sleep(3000);        ThreadB threadB = new ThreadB(lock);        threadB.setName(&quot;B&quot;);        threadB.start();    } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}  }</code></pre><p>运行结果如下图：<br>  <img src="https://upload-images.jianshu.io/upload_images/1453857-070a66f33dd162b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.png"></p><p>从打印结果来看，3S后线程别nofity唤醒.<br>我们再来实现下之前的上面那个例子：<br>ThreadA:</p><pre><code>        package com.notrace;    public class ThreadA extends Thread {private Object lock;public ThreadA(Object lock) {    super();    this.lock = lock;}@Overridepublic void run() {    try {        synchronized (lock) {            if(Data.getSize()!=6)            System.out.println(&quot;begin wait time&quot; +       System.currentTimeMillis());            lock.wait();            System.out.println(&quot;end wait time&quot; + System.currentTimeMillis());        }    } catch (Exception e) {        e.printStackTrace();    }}}</code></pre><p>ThreadB:</p><pre><code>        package com.notrace;  public class ThreadB extends Thread{    private Object  lock;  public ThreadB(Object lock) {    super();    this.lock=lock;}@Overridepublic void run() {    try {    synchronized (lock) {        for (int i = 0; i &lt; 10; i++) {            Data.add();            if(Data.getSize()==6) {                lock.notify();                System.out.println(&quot;发出通知&quot;);            }            System.out.println(&quot;添加了&quot;+(i+1)+&quot;个元素&quot;);            Thread.sleep(1000);        }            }} catch (Exception e) {    e.printStackTrace();    System.out.println(e.toString());}}}</code></pre><p>Data:</p><pre><code>        package com.notrace;  import java.util.ArrayList;  import java.util.List;  public class Data {private static List list = new ArrayList();public static void add() {    list.add(&quot;notrace&quot;);}public static int getSize() {    return list.size();}    }</code></pre><p>Test:</p><pre><code>      package com.notrace;    public class Test {public static void main(String[] args) {    try {        Object lock = new Object();        ThreadA threadA = new ThreadA(lock);        threadA.setName(&quot;A&quot;);        threadA.start();        Thread.sleep(50);        ThreadB threadB = new ThreadB(lock);        threadB.setName(&quot;B&quot;);        threadB.start();    } catch (InterruptedException e) {        // TODO Auto-generated catch block        e.printStackTrace();    }}}</code></pre><p>运行结果如下:<br><img src="https://upload-images.jianshu.io/upload_images/1453857-584bcf34b652abb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p><p>日志说明了一个问题,notify()调用之后，并不会立即释放锁，而是会接着执行后面的代码，执行完了，才会释放锁。</p><p>synchronized可以将任何一个Object对象作为同步对象来看待，每个Object都实现了wait()和notify()。他们必须用被用在synchronized同步的区域内，wait()让区域内的线程进入等待状态，释放同步锁，notify()可以唤醒一个因调用了wait()而处于等待状态中的线程。被唤醒的线程继续执行wait()后面的代码。如果notify之后没有处于阻塞等待中的线程，就会被忽略。<br>关于释放锁，有以下几个结论，<br>1）执行完同步代码块，就会释放锁。<br>2）执行代码块的过程中，如果遇到异常而导致线程终止，也会释放锁。<br>3）调用wait()这个线程会释放锁。</p><p>另外还有一点，需要提一下。notify()只会唤醒一个线程，所以在多线程的时候，可能会出现一些问题，所以，尽量用notifyAll()唤醒所有等待的线程 比较好。下面来看看另一个经典问题。</p><p>###生产者/消费者模式</p><p>###一个生产者，一个消费者<br>废话不多说，直接看code.<br>生产者P:</p><pre><code>            package com.notrace;  //生产者  public class P {private String lock;public P(String lock) {    super();    this.lock=lock;}public void setValue() {    try {        synchronized (lock) {            if(!ValueObj.value.equals(&quot;&quot;)) {                lock.wait();            }            String value=System.currentTimeMillis()+&quot;&quot;;            System.out.println(&quot;set的值：&quot;+value);            ValueObj.value=value;            lock.notify();        }    } catch (Exception e) {        // TODO: handle exception    }}}</code></pre><p>消费者C:</p><pre><code>  package com.notrace;    //消费者    public class C {private String lock;public C(String lock) {    super();    this.lock=lock;}public void getValue() {try {    synchronized (lock) {        if(ValueObj.value.equals(&quot;&quot;)) {            lock.wait();        }        System.out.println(&quot;get的值:&quot;+ValueObj.value);        ValueObj.value=&quot;&quot;;        lock.notify();    }} catch (Exception e) {    // TODO: handle exception}}}</code></pre><p>线程P：</p><pre><code>    package com.notrace;public class ThreadP extends Thread{private P p;public ThreadP(P p) {    super();    this.p=p;}@Overridepublic void run() {    while(true) {        p.setValue();    }}}</code></pre><p>线程C：</p><pre><code>            package com.notrace;  public class ThreadC extends Thread{private C c;public ThreadC(C c) {    super();    this.c=c;}@Overridepublic void run() {    while(true) {        c.getValue();    }}}</code></pre><p>Run：</p><pre><code>          package com.notrace;public class Run {public static void main(String []args) {    String lock=new String(&quot;&quot;);    P p=new P(lock);    C c=new C(lock);    ThreadP tP=new ThreadP(p);    ThreadC tC=new ThreadC(c);    tP.start();    tC.start();}}</code></pre><p>运行结果：<br><img src="https://upload-images.jianshu.io/upload_images/1453857-eb6739d745cb9929.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.png"></p><p>可以看出来，是生产者，消费者，交替运行的。</p><p>接下来变化一下:</p><p>######多生产者，多消费者</p><p>P:</p><pre><code>    package com.notrace;  //生产者  public class P {private String lock;public P(String lock) {    super();    this.lock=lock;}public void setValue() {    try {        synchronized (lock) {            while(!ValueObj.value.equals(&quot;&quot;)) {                System.out.println(&quot;生产者:&quot;+Thread.currentThread().getName()+&quot;watting*&quot;);                lock.wait();            }            System.out.println(&quot;生产者:&quot;+Thread.currentThread().getName()+&quot;run*&quot;);            String value =System.currentTimeMillis()+&quot;&quot;;            ValueObj.value=value;            lock.notify();        }    } catch (Exception e) {        // TODO: handle exception    }}}</code></pre><p>C:</p><pre><code>  package com.notrace;//消费者  public class C {private String lock;public C(String lock) {    super();    this.lock=lock;}public void getValue() {try {    synchronized (lock) {        while(ValueObj.value.equals(&quot;&quot;)) {            System.out.println(&quot;消费者:&quot;+Thread.currentThread().getName()+&quot;waitting&quot;);            lock.wait();        }        System.out.println(&quot;消费者:&quot;+Thread.currentThread().getName()+&quot;run&quot;);        System.out.println(&quot;get的值:&quot;+ValueObj.value);        ValueObj.value=&quot;&quot;;        lock.notify();    }} catch (Exception e) {    // TODO: handle exception}}}</code></pre><p>threadP，threadC一样:</p><p>Run:</p><pre><code>        package com.notrace;  public class Run {public static void main(String []args) {    try {        String lock=new String(&quot;&quot;);        P p=new P(lock);        C c=new C(lock);        ThreadP[] pThreadPs=new ThreadP[2];        ThreadC[]cThreadCs=new ThreadC[2];        for(int i=0;i&lt;2;i++) {            pThreadPs[i]=new ThreadP(p);            pThreadPs[i].setName(&quot;生产者&quot;+(i+1));            cThreadCs[i]=new ThreadC(c);            cThreadCs[i].setName(&quot;消费者&quot;+(i+1));            pThreadPs[i].start();            cThreadCs[i].start();        }        Thread.sleep(5000);        } catch (Exception e) {        // TODO: handle exception    }}  }</code></pre><p>执行完：<br><img src="https://upload-images.jianshu.io/upload_images/1453857-c2d2686d93ecd77d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.png"></p><p>两个都是等待，而且还没执行完，是不是很奇怪。。。产生这种情况是因为唤醒的早了点， 生产者1唤醒了生产者2，然而生产者2发现产品并未被消费，所以生产者2也是wait状态。另外，还有种原因，就是连续唤醒同类。解决这种问题，就需要将P和C中的notify改成notifyAll()，将生产者和消费者一起唤醒，就ok了。</p><p>咱接着变</p><p>######一生产一消费：来操作栈<br>这个场景就是生产者向堆栈List中放数据，消费者从List中取数据。list最大容量是1:<br>p:</p><pre><code>        package com.notrace;  //生产者  public class P {private MyStack stack;public P(MyStack stack) {    super();    this.stack=stack;}public void pushService() {    stack.push();}}</code></pre><p>C:</p><pre><code>        package com.notrace;  //消费者public class C {private MyStack stack;public C(MyStack stack) {    super();    this.stack=stack;}public void popService() {    System.out.println(&quot;pop=&quot;+stack.pop());}  }</code></pre><p>MyStack:</p><pre><code>        package com.notrace;  import java.util.ArrayList;  import java.util.List;  public class MyStack {  private List list=new ArrayList&lt;&gt;();  synchronized public void push() {try {    if(list.size()==1) {        this.wait();    }    list.add(&quot;notrace:&quot;+Math.random());    this.notify();    System.out.println(&quot;push=&quot;+list.size());} catch (Exception e) {    // TODO: handle exception}  }      synchronized public String pop() {String value=&quot;&quot;;try {    if(list.size()==0) {        System.out.println(&quot;pop操作&quot;+Thread.currentThread().getName());        this.wait();    }    value=&quot;&quot;+list.get(0);    list.remove(0);    this.notify();    System.out.println(&quot;pop&quot;+list.size());} catch (Exception e) {    // TODO: handle exception}return value;  }}</code></pre><p>ThreadP:</p><pre><code>        package com.notrace;  public class ThreadP extends Thread{private P p;public ThreadP(P p) {    super();    this.p=p;}@Overridepublic void run() {    while(true) {        System.out.print(&quot;&quot;);        p.pushService();//            p.setValue();    }}}</code></pre><p>ThreadC:</p><pre><code>        package com.notrace;public class ThreadC extends Thread{private C c;public ThreadC(C c) {    super();    this.c=c;}@Overridepublic void run() {    while(true) {        System.out.print(&quot;&quot;);        c.popService();  //            c.getValue();    }}  }</code></pre><p>Run:</p><pre><code>package com.notrace;</code></pre><p>public class Run {<br>    public static void main(String []args) {</p><pre><code>    MyStack stack=new MyStack();    P p=new P(stack);    C c=new C(stack);    ThreadP threadP=new ThreadP(p);    ThreadC threadC=new ThreadC(c);    threadP.start();    threadC.start();}}</code></pre><p>执行结果：<br><img src="https://upload-images.jianshu.io/upload_images/1453857-eb44c5bbfbef7611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.png"></p><p>程序的结果是size不会大于1|。</p><p>###一生产多消费：来操作栈<br>代码还是上面的那些，我们改一下Run：</p><pre><code>        package com.notrace;public class Run {public static void main(String []args) {    MyStack stack=new MyStack();    P p=new P(stack);    C c1=new C(stack);    C c2=new C(stack);    C c3=new C(stack);    C c4=new C(stack);    C c5=new C(stack);    ThreadP threadP=new ThreadP(p);    ThreadC threadC1=new ThreadC(c1);    ThreadC threadC2=new ThreadC(c2);    ThreadC threadC3=new ThreadC(c3);    ThreadC threadC4=new ThreadC(c4);    ThreadC threadC5=new ThreadC(c5);    threadP.start();    threadC1.start();    threadC2.start();    threadC3.start();    threadC4.start();    threadC5.start();  }  }</code></pre><p>执行结果：<img src="https://upload-images.jianshu.io/upload_images/1453857-e4a1b50023c36141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.png"></p><p>假死状态了，多次执行。还可能会出现indexoutofbounce，这是因为条件改变时并没有得到及时的响应，引起了list.remove(0)报错，解决办法是将MyStack中的if()判断改为while()。多消费一生产，多消费多生产，也是一样的。改一下run里面的代码就行了</p><p>好了，基本完事。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;/p&gt;
&lt;script src=&quot;http://cdn.bootc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用androidstudio编写第一个xposed模块</title>
    <link href="https://messnoTrace.github.io/2019/04/05/%E7%94%A8androidstudio%E7%BC%96%E5%86%99%E7%AC%AC%E4%B8%80%E4%B8%AAxposed%E6%A8%A1%E5%9D%97/"/>
    <id>https://messnoTrace.github.io/2019/04/05/用androidstudio编写第一个xposed模块/</id>
    <published>2019-04-05T02:36:55.000Z</published>
    <updated>2019-04-05T03:34:54.262Z</updated>
    
    <content type="html"><![CDATA[<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  </p><p><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  </p><p><script>hljs.initHighlightingOnLoad();</script><br>前提：你的手机装了xposedinstaller ，已经获取root权限，否则以下内容不用看了。<br>参考链接:<a href="https://blog.csdn.net/mrglaucusss/article/details/50963542" target="_blank" rel="external">https://blog.csdn.net/mrglaucusss/article/details/50963542</a></p><p>####配置准备工作<br>我的as版本是3.1的。所以基于此版本做操作</p><ul><li>新建一个工程包名随便取。我取了com.notrace</li><li><p>MainActivity代码简单如下:</p><pre><code>          package com.notrace;    import android.support.v7.app.AppCompatActivity;  import android.os.Bundle;  import android.view.View;  import android.widget.Toast;  public class MainActivity extends AppCompatActivity {  @Override    protected void onCreate(Bundle savedInstanceState) {      super.onCreate(savedInstanceState);      setContentView(R.layout.activity_main);      findViewById(R.id.buttonPanel).setOnClickListener(new View.OnClickListener() {          @Override          public void onClick(View v) {          Toast.makeText(MainActivity.this,hook(),Toast.LENGTH_SHORT).show();          }      });  }  public String hook(){  return &quot;未被劫持&quot;;  }}</code></pre></li></ul><p>很简单，一个button点击弹出toast，显示hook函数返回值,我的目标就是修改这个hook的返回值</p><ul><li><p>修改清单文件，在application节点下添加</p><pre><code>              &lt;meta-data    android:name=&quot;xposedmodule&quot;    android:value=&quot;true&quot; /&gt;&lt;meta-data    android:name=&quot;xposeddescription&quot;    android:value=&quot;你猜猜&quot; /&gt;&lt;meta-data    android:name=&quot;xposedminversion&quot;    android:value=&quot;54&quot; /&gt;</code></pre></li></ul><p>第一个表示是否是xposed模块<br>第二个是描述，随便你写<br>第三个是最低的api版本支持</p><ul><li><p>修改app/gradle</p><pre><code>      repositories {    jcenter()}dependencies {  compileOnly &apos;de.robv.android.xposed:api:82&apos;  compileOnly &apos;de.robv.android.xposed:api:82:sources&apos;  implementation &apos;com.android.support:appcompat-v7:27.1.1&apos;  implementation &apos;com.android.support.constraint:constraint-layout:1.1.0&apos;  testImplementation &apos;junit:junit:4.12&apos;  androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos;  androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos;}</code></pre></li></ul><p>注意，上面两个一定要修改为compileOnly 如果你是低版本的as可以改成provided </p><p>#####代码</p><ul><li>新建HookTest 类：</li></ul><pre><code>          package com.notrace;        import de.robv.android.xposed.IXposedHookLoadPackage;        import de.robv.android.xposed.XC_MethodHook;        import de.robv.android.xposed.XposedBridge;      import de.robv.android.xposed.XposedHelpers;      import de.robv.android.xposed.callbacks.XC_LoadPackage;      public class HookTest implements IXposedHookLoadPackage {          @Override          public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam)           throws Throwable {    if(loadPackageParam.packageName.equals(&quot;com.notrace&quot;)){        XposedBridge.log(&quot;NOTRACE&quot;+loadPackageParam.packageName);        Class clazz=loadPackageParam.classLoader.loadClass(&quot;com.notrace.MainActivity&quot;);        XposedHelpers.findAndHookMethod(clazz, &quot;hook&quot;, new XC_MethodHook() {            @Override            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {                super.beforeHookedMethod(param);            }            @Override            protected void afterHookedMethod(MethodHookParam param) throws Throwable {                param.setResult(&quot;你已经被劫持了&quot;);            }        });    }}  }</code></pre><ul><li>添加xposed入口，新建assets：<img src="https://upload-images.jianshu.io/upload_images/1453857-7f9d3d644e31ea0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信截图_20180511182235.png"></li></ul><p>xposed_init内容如下：</p><pre><code>com.notrace.HookTest</code></pre><ul><li>至此结束，然后如果你没有禁用instant run 那么你就得打一个带签名的安装包，然后安装到手机上，然后再xposed installer模块中勾选你编写的module，然后手机重启生效。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;http://cdn.bo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android如何在子module中取获取主module中通过网络接口请求返回的数据？</title>
    <link href="https://messnoTrace.github.io/2019/04/05/Android%E5%A6%82%E4%BD%95%E5%9C%A8%E5%AD%90module%E4%B8%AD%E5%8F%96%E8%8E%B7%E5%8F%96%E4%B8%BBmodule%E4%B8%AD%E9%80%9A%E8%BF%87%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E8%AF%B7%E6%B1%82%E8%BF%94%E5%9B%9E%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9F/"/>
    <id>https://messnoTrace.github.io/2019/04/05/Android如何在子module中取获取主module中通过网络接口请求返回的数据？/</id>
    <published>2019-04-05T02:35:18.000Z</published>
    <updated>2019-04-05T03:47:26.075Z</updated>
    
    <content type="html"><![CDATA[<p><link href="http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css" rel="stylesheet">  </p><p><script src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>  </p><p><script>hljs.initHighlightingOnLoad();</script><br>如题：今天遇到一个需求，在子module中获取主module中通过网络接口异步返回的数据？嗯。。绕了一下午把自己绕进去了，简单来说，就两个回调完事。一个request，一个response。但是胡思乱想了一下午，很是尴尬，废话不多说，咱直接上代码。</p><p>###首先一个request接口：<br>            public interface IRequest {<br>    public void request(IResponse response);<br>      }</p><p>###然后一个response接口</p><pre><code>        public interface IResponse {void response(String result);  }</code></pre><p>###一个通信管理<br>            public class BridgeManager {<br>    private IRequest request;</p><pre><code>public void registerCallback(IRequest request) {    this.request = request;}public IRequest getRequest() {    return request;}public void setRequest(IRequest request) {    this.request = request;}}</code></pre><p>###为了方便扩展，我们再来一个通信管理的list的管理容器<br>            public class BrigeListManager {<br>    private static class SingletonHolder {</p><pre><code>    private static final BrigeListManager sInstance = new BrigeListManager();}public static BrigeListManager getInstance() {    return SingletonHolder.sInstance;}private BridgeManager bridgeManager;public BridgeManager getBridgeManager() {    return bridgeManager;}public void setBridgeManager(BridgeManager bridgeManager) {    this.bridgeManager = bridgeManager;} }</code></pre><h3 id="我们再来写一个主工程模拟网络请求的东东"><a href="#我们再来写一个主工程模拟网络请求的东东" class="headerlink" title="我们再来写一个主工程模拟网络请求的东东"></a>我们再来写一个主工程模拟网络请求的东东</h3><pre><code>      public class MainModuleImpl extends BridgeManager{public MainModuleImpl(){    registerCallback(new IRequest() {        @Override        public void request(IResponse response) {            try {                Thread.sleep(3000);                System.out.print(&quot;耗时任务执行完毕&quot;);                response.response(&quot;给子module返回结果&quot;);            }catch (Exception e){            }        }    });}   }</code></pre><h3 id="然后随便在写一个主工程中初始化的地方-具体情况具体考察，我只模拟一下下"><a href="#然后随便在写一个主工程中初始化的地方-具体情况具体考察，我只模拟一下下" class="headerlink" title="然后随便在写一个主工程中初始化的地方,具体情况具体考察，我只模拟一下下"></a>然后随便在写一个主工程中初始化的地方,具体情况具体考察，我只模拟一下下</h3><pre><code>        public class MainModule {MainModule(){    BrigeListManager.getInstance().setBridgeManager(new MainModuleImpl());} }</code></pre><h3 id="完事了，我们模拟一下子module中如何获取"><a href="#完事了，我们模拟一下子module中如何获取" class="headerlink" title="完事了，我们模拟一下子module中如何获取"></a>完事了，我们模拟一下子module中如何获取</h3><pre><code>          public class Test {public static void main(String args[]) {    MainModule mainModule=new MainModule();    IResponse response = new IResponse() {        @Override        public void response(String result) {            System.out.print(result);        }    };    BrigeListManager.getInstance().getBridgeManager().getRequest().request(response);}   }</code></pre><h6 id="end"><a href="#end" class="headerlink" title="end"></a>end</h6><p>   <img src="https://upload-images.jianshu.io/upload_images/1453857-b084f81966313e54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20181129-212144@2x.png"></p><p>嗯，，，美滋滋吧，虽说代码不难，但是不知道为什么，却让我想的很是难受，恼火，可能年纪大了，😔</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;link href=&quot;http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css&quot; rel=&quot;stylesheet&quot;&gt;  &lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;http://cdn.bo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>资源索引</title>
    <link href="https://messnoTrace.github.io/2019/04/05/%E8%B5%84%E6%BA%90%E7%B4%A2%E5%BC%95/"/>
    <id>https://messnoTrace.github.io/2019/04/05/资源索引/</id>
    <published>2019-04-05T02:24:05.000Z</published>
    <updated>2019-04-05T02:46:50.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="hexo-使用教程"><a href="#hexo-使用教程" class="headerlink" title="hexo 使用教程"></a>hexo 使用教程</h3><p><a href="[http://fangzh.top/2018/2018090715/](http://fangzh.top/2018/2018090715/">hexo教程:基本配置+更换主题+多终端工作+coding page部署分流(2)</a><br>)<br> <a href="https://www.cnblogs.com/jackyroc/p/7681938.html" target="_blank" rel="external">我是如何利用Github Pages搭建起我的博客，细数一路的坑</a><br><a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="external">hexo-theme-aircloud主题</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;hexo-使用教程&quot;&gt;&lt;a href=&quot;#hexo-使用教程&quot; class=&quot;headerlink&quot; title=&quot;hexo 使用教程&quot;&gt;&lt;/a&gt;hexo 使用教程&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;[http://fangzh.top/2018/201809071
      
    
    </summary>
    
    
  </entry>
  
</feed>
