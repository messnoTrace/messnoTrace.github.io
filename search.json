[{"title":"Android 多渠道打包修改app name，icon","url":"/2019/04/05/Android-多渠道打包修改app-name，icon/","content":"<link href=\"http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css\" rel=\"stylesheet\">  \n<script src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\"></script>  \n<script >hljs.initHighlightingOnLoad();</script>  \n搞过多渠道打包的都知道，我们只需要在 module 的build.gradle中配置相应的渠道号就行:\n\n                   \n                    productFlavor{\n                              baidu {\n                              }\n                            xiaomi{}\n                             wandoujia{}\n                        }\n像这样，就可以了，然后将友盟的chanelvalue修改下就可以了，需要不同的渠道，配置不同的applicationid，也不是什么难事。不过今天我遇到的需求是，不同的渠道配置不同的appname和icon。一开始我想着用之前的哪种方法应该可行，然后就试了下，一试不知道，试过就蛋疼了，appname是可以换掉，但是icon呢，，咋整，，，找了一圈方法，都木有找到，郁闷，string类型的，都可以通过常用的那种替换占位符的方式来改，或者是resValue(这个没有试，，但是似乎是可以的)。然后各种搜资料，有什么设置 useOldManifestMerger false ，不过自己没试成功（不能怪我，理论是这个道理的，只不过gradle版本不一样，Google升级了，导致我懵逼了）偶然间Google了一下  how to change app icon for diffrent productFlavors in android，点开第一个[链接](http://stackoverflow.com/questions/22875948/how-to-provide-different-android-app-icons-for-different-gradle-buildtypes),然后答主的答案给了我一些启发：\n\n\n![QQ截图20160811184619.png](http://upload-images.jianshu.io/upload_images/1453857-3cbf6c005c8c592c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后搜啊搜，又找到了[这个](http://stackoverflow.com/questions/25981156/tools-replace-not-replacing-in-android-manifest)\n\n\n\n\n![QQ截图20160811185123.png](http://upload-images.jianshu.io/upload_images/1453857-0c8656280ca0a302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n然后经过自己的摸索，搞了出来了，简单来说：\n大家看第一张图你的目录结构就会发现，如果我们在src/main/文件夹下新建以我们去渠道名为名的，目录结构和main一样的文件目录，当我们打包的时候就会读取这里面的资源文件，所以呢，我就新建了个清单文件，将头部换成图二所示，在根目录添加\n\n                  xmlns:tools=\"http://schemas.android.com/tools\"\n\n然后application\n  \n          tools:replace=\"android:icon\" \n          android:icon=\"@drawable/icon_all\"\n\n替换你需要换的icon就行，ok，至此搞定，至于为什么这么搞，我看到了官方的一篇文章[清单合并](http://tools.android.com/tech-docs/new-build-system/user-guide/manifest-merger#TOC-Manifest-files-ordering),另外还有篇国内[译文](http://blog.csdn.net/maosidiaoxian/article/details/42671999)\n\n\n剩下的就靠小伙伴么自己摸索了。。。。"},{"title":"AndroidStudio中调用.so包出现找不到.so包的错误","url":"/2019/04/05/AndroidStudio中调用-so包出现找不到-so包的错误/","content":"<link href=\"http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css\" rel=\"stylesheet\">  \n<script src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\"></script>  \n<script >hljs.initHighlightingOnLoad();</script>  \n\n![QQ截图20160721125018.png](http://upload-images.jianshu.io/upload_images/1453857-0fb31dfbb366a918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n###出现原因\nRT,在Andoridsutdio中调用.so库出现如现标题所示错误，该怎么解决。首先出现这个错误的原因是因为你的cpu架构是64位的。而你的.so库在编译的时候没有支持64位cpu。**  如果这个.so的库是你自己弄的，那你重新生成下支持64位cpu的.so库出来就行了，剩下的文字就不用看了，本文适用于你没法对.so做操作的朋友。** 查看cpu架构，可以通过adb shell 命令。进入/system/目录下有一个build.prop文件，这个里面有一行 ro.product.cpu.abi=xx就是你所要的信息，具体命令如下:\n\n                    adb shell\n                    cd /system\n                    cat build.prop\n\n\napk包在安装的时候，系统会把包中与自己的abi对应的lib目录中的so库文件拷贝到system分区中，32位机器中只有一个目录/system/lib，64位机器中有两个目录/system/lib和/system/lib64，app启动进行链接时，64位机器中会先到/system/lib64目录中去找，这时候肯定找不到。如果没有找到再到/system/lib目录中去找。如果你把32位的so库拷贝到了lib64目录中，会导致链接失败，同样，64位的so库被拷贝到lib目录中也会导致失败，所以so库要和目录一一对应。\n\n###解决方案\n首先我的目录结构是这样的：\n![QQ截图20160721123538.png](http://upload-images.jianshu.io/upload_images/1453857-be5473a00f8f04a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n我的.so并没有放在新建的jniLibs目录中，这个关系应该不大，两种方式都可以。\n我的cpu架构是 ro.product.cpu.abi=arm64-v8a\n而我的只有一个CPU架构就是armebi-v7a,我们要做的就是阻止生成arm64-v8a;\n正常情况打开apk的lib结构如下：\n![QQ截图20160721124748.png](http://upload-images.jianshu.io/upload_images/1453857-5e5183dd73f1ac09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n方案如下：\n* 首先在project目录下的 gradle.properties中添加一句 \n              android.useDeprecatedNdk=true\n* 在app的build.gradle中的defaulConfig下添加如下：\n            ndk {  \n              abiFilters \"armeabi\", \"armeabi-v7a\", \"x86\", \"mips\"\n            }\n\n\n这时候你解压开生成的apk包，会发现目录lib结构如下：\n\n![QQ截图20160721124539.png](http://upload-images.jianshu.io/upload_images/1453857-df30fc0704288587.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nOK，这样就解决了我的这个问题，网络上有一些别的阻止生成arm64-v8a，但是不好使。"},{"title":"Android通过反射实现静默安装","url":"/2019/04/05/Android通过反射实现静默安装/","content":"<link href=\"http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css\" rel=\"stylesheet\">  \n<script src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\"></script>  \n<script >hljs.initHighlightingOnLoad();</script>  \n\n本文讲解通过反射Android pm  instal来调用隐藏api， 来静默安装，至于原理什么的，就不多说了，网络上一搜一大把，下面是亲测可行的；\n先上[Demo](https://github.com/messnoTrace/SlienceInstall),其中的libs文件夹下的class.jar是主角。\n本文有一个大前提，那就是你的apk是放在系统/system/priv-app目录下，也就是说，rom是你们自己搞的，手动滑稽=。= \n如果你是用AndroidStudio版本的，也是链接中的[DemoSilenceInstall](https://github.com/messnoTrace/SlienceInstall/tree/master/DemoSilenceInstall)\n步骤如下：\n * 建一个你自己的工程 ，将class.jar放入到libs目录下。\n * 然后projectStructure(按F4直接进)，进入dependence点击+号，选择FileDependence 记得把 scope置为Provided，如下图:\n![1.png](http://upload-images.jianshu.io/upload_images/1453857-d74f2be33a1b022c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* 工程目录下的gradle文件修改：\n              allprojects {  \n                repositories {      \n                          jcenter()   \n                       }  \n                          gradle.projectsEvaluated {             \n                                   tasks.withType(JavaCompile) {     \n                                                 options.compilerArgs.add('-Xbootclasspath/p:app\\\\libs\\\\class.jar')                  \n                                }  \n                               }\n                          }\n\n     **看好名字,不要眼瞎，后面是你起的jar包的名字，这个名字随意取，两者对应就行，**\n\n    以上的操作的目的有两个：\n      1.就是将class.jar以eclipse中那种userlib的形式导入，\n      2.调整jar包的优先级\n* 再将demo中install 包下的代码放到你的工程中.如果这个时候你的PM.java这个文件不报错，那么恭喜，你的操作就算完成了\n* 这个步骤我的代码出现了问题，不知道你的会不会，就是Android中65535问题了，也就是解决这个问题做的操作，AS下好解决，这个不做过多解释。\n\n\n剩下的，就是将应用打包签名，放到/system/priv-app这个目录下 就ok了，\n\n下面说下Eclipse版本的操作，代码都是一样的，jar包也是一样，就两点，jar包通过userlibrary的形式导入，直接放图吧，多图慎入：\n![\n![Uploading 4_049957.png . . .]\n](http://upload-images.jianshu.io/upload_images/1453857-e9e8d436fbd4ddde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![3.png](http://upload-images.jianshu.io/upload_images/1453857-d5b134f0db69b9a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![4.png](http://upload-images.jianshu.io/upload_images/1453857-cecd54290fd90360.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![\n\n![Uploading 6_086779.png . . .]\n](http://upload-images.jianshu.io/upload_images/1453857-e6cde6675deb959b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![6.png](http://upload-images.jianshu.io/upload_images/1453857-16490fdfd7ab0de6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n\n![7.png](http://upload-images.jianshu.io/upload_images/1453857-73ac54c47095b33b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n![8.png](http://upload-images.jianshu.io/upload_images/1453857-c524e6d1cb374503.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![9.png](http://upload-images.jianshu.io/upload_images/1453857-c57017127dc439c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n![\n![Uploading 10_162291.png . . .]\n](http://upload-images.jianshu.io/upload_images/1453857-d0b9e66477c90d60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n![11.png](http://upload-images.jianshu.io/upload_images/1453857-8fd7af66b59e3784.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n至此，，搞定了，╮(╯▽╰)╭，继续搬砖。如果你要问这个class怎么来的，你找做rom的大神们给你编译一份源码就行，反正我不会。OTZ.... 然而这个地方在我写完文章后又出现了一个实战问题，那就是用multydex分包处理后，还是会出现 [Too many classes in --main-dex-list, main dex capacity exceeded](http://stackoverflow.com/questions/32721083/too-many-classes-in-main-dex-list-main-dex-capacity-exceeded)，，目前一个最简单暴力的方法就是把minsdkversion 调成21+，我在想想办法，，，，解决了更新文章。\n\n\n(⊙o⊙)…，暂时没解决，不过上了一个新版本，用aidl实现的，也是可以用[这里的](https://github.com/messnoTrace/SlienceInstall/tree/master/MyApplication)...东西都差不多，jar包换了个精简的，然后改用aidl实现的注意，aidl的包名不要动，，，然后配置下gradle里面的aidl\n"},{"title":"Android修改CheckBoxPreference 中title ，summary字体的颜色","url":"/2019/04/05/Android修改CheckBoxPreference-中title-，summary字体的颜色/","content":"<link href=\"http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css\" rel=\"stylesheet\">  \n<script src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\"></script>  \n<script >hljs.initHighlightingOnLoad();</script>  \n\n以前没怎么关注过PreferenceActivity的一些用法只是简单了解下，然后刚好今天遇到了某个机型上出现了问题：**我明明设置的是黑色的字体，在这个机器上却是白色的**，然后各种摸索得出了个推论，页面的字体颜色什么的，可能是更随系统来的，受系统调控：\n我是这么写的，\n\n                <CheckBoxPreference    \n                android:defaultValue=\"true\"   \n               android:key=\"weather_use_metric\"  \n              android:textColor=\"@color/black\"\n                android:title=\"@string/weather_use_metric\" />\n\n问题出现 了那没办法，只能想办法改了，好在现在学会了面向google编程，然后搜的一下，找到了个解决方案，先上怎么解决，然后再说为什么这么干。首先建个layout ，名字随便取（我取名custom_preferece_layout.xml），内容如下:\n\n              <LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" \n                 android:layout_width=\"match_parent\"\n               android:layout_height=\"wrap_content\"   \n               android:minHeight=\"?android:attr/listPreferredItemHeight\" \n               android:gravity=\"center_vertical\" \n               android:paddingRight=\"?android:attr/scrollbarSize\">  \n            <RelativeLayout android:layout_width=\"wrap_content\"        \n              android:layout_height=\"wrap_content\" android:layout_marginLeft=\"15dip\"   \n             android:layout_marginRight=\"6dip\"\n             android:layout_marginTop=\"6dip\"      \n             android:layout_marginBottom=\"6dip\" \n             android:layout_weight=\"1\">     \n            <TextView android:id=\"@+android:id/title\"       \n               android:layout_width=\"wrap_content\" \n             android:layout_height=\"wrap_content\"         \n             android:singleLine=\"true\" \n              android:textAppearance=\"?android:attr/textAppearanceLarge\"        \n              android:ellipsize=\"marquee\" android:fadingEdge=\"horizontal\"         \n             android:textColor=\"@color/black\" />    \n            <TextView android:id=\"@+android:id/summary\"     \n             android:layout_width=\"wrap_content\" \n            android:layout_height=\"wrap_content\"          \n            android:layout_below=\"@android:id/title\" \n            android:layout_alignLeft=\"@android:id/title\"           \n           android:textAppearance=\"?android:attr/textAppearanceSmall\"        \n           android:maxLines=\"4\" />   \n       </RelativeLayout>    \n    <!-- Preference should place its actual preference widget here. -->  \n        <LinearLayout android:id=\"@+android:id/widget_frame\"     \n           android:layout_width=\"wrap_content\"\n           android:layout_height=\"match_parent\"        \n          android:gravity=\"center_vertical\" android:orientation=\"vertical\" />\n      </LinearLayout>\n\n在这个布局中修改title，sunmmary的颜色就可以了。\n然后再CheckBoxPreference    中加一句：\n\n\n          <CheckBoxPreference   \n           android:defaultValue=\"true\"   \n             android:key=\"weather_use_metric\"  \n            android:layout=\"@layout/custom_preferece_layout\" \n            android:textColor=\"@color/black\"   \n               />\n然后，就解决了这个问题，那为什么这么搞呢？进入CheckBoxPreference   顶层父类Preference中看，看到构造中的注释了：\n\n\n![QQ截图20161110175559.png](http://upload-images.jianshu.io/upload_images/1453857-fca483c577435efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n这玩意默认的控制了样式，然后再往下看到一个方法：\n\n\n![QQ截图20161110175911.png](http://upload-images.jianshu.io/upload_images/1453857-54f7fd8444a953dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n他说大部分情况足够用了，但是这不是出来问题么，于是到android的values中的attr下找，\n\n\n![Paste_Image.png](http://upload-images.jianshu.io/upload_images/1453857-e5a69f67b3b10c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n嗯很贴心，行数都截出来了。顶层默认实现了个布局，在CheckBoxPreference的onBindView方法中出现了个id和一个方法：\n![QQ截图20161110181103.png](http://upload-images.jianshu.io/upload_images/1453857-30381fbc2e2d3ff8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nid点进去能找到个布局，然后再父类TwoStatePreference中可以看到这个方法里面写了什么，注意看上面的布局控件的id，你没看错，就是覆盖了preference_material.xml 中的布局：\n\n\n![QQ截图20161110181315.png](http://upload-images.jianshu.io/upload_images/1453857-c2fb7896c6189aba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n附上答案链接 [http://stackoverflow.com/questions/4469514/how-to-customize-text-color-of-the-checkboxpreference-title](http://stackoverflow.com/questions/4469514/how-to-customize-text-color-of-the-checkboxpreference-title)\n"},{"title":"Android Accessbility的简单用法","url":"/2019/04/05/Android-Accessbility的简单用法/","content":"<link href=\"http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css\" rel=\"stylesheet\">  \n<script src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\"></script>  \n<script >hljs.initHighlightingOnLoad();</script>  \nAccessbility 又叫做辅助功能，是Android官方推出帮助身体不便或者操作不灵活的人来辅助操作的，也可以用来干一些别的事，比如自动抢红包啊，静默安装点击啊等已知或者未知的应用。出于某种需求，就研究了下这个功能的简单用法，先做一个模拟按钮点击的效果。\n  布局很简单，就不贴代码了，简单描述下，主界面就一个按钮，id随便你取，在Activity中设置点击事件，弹出一个Toast。\n\n#####步骤\n1. 创建CheckAccessbilityServices：\n CheckAccessbilityServices 继承自AccessibilityService，并在清单文件applcation节点中配置，并加入权限\n    \n          <service   \n           android:name=\".CheckAccessbilityServices\"   \n           android:enabled=\"true\"        \n          android:exported=\"true\"\n          android:label=\"测试点击\"\n          android:permission=\"android.permission.BIND_ACCESSIBILITY_SERVICE\">  \n              <intent-filter>      \n                <action android:name=\"android.accessibilityservice.AccessibilityService\" />\n                </intent-filter> \n             <meta-data\n                   android:name=\"android.accessibilityservice\"\n                   android:resource=\"@xml/check_accessibility_config\" />\n          </service>'\n2.在res目录下创建文件夹xml，并创建步骤一中check_accessibility_config.xml\n\n            <accessibility-service xmlns:android=\"http://schemas.android.com/apk/res/android\"                   android:description=\"@string/check_click\" \n                android:packageNames=\"com.notrace\"      \n            android:accessibilityEventTypes=    \"typeAllMask|typeViewClicked|typeViewFocused|typeNotificationStateChanged|typeWindowStateChanged\"    \n              android:accessibilityFlags=\"flagDefault\"   \n              android:accessibilityFeedbackType=\"feedbackSpoken\"    \n              android:notificationTimeout=\"100\"   \n              android:canRetrieveWindowContent=\"true\"    />\n这里面有一些常用的属性，简单介绍下\n          android:accessibilityEventTypes=\"typeAllMask\"\n看属性名也差不多可以明白，这个是用来设置响应事件的类型，typeAllMask当然就是响应所有类型的事件了。当然还有单击、长按、滑动等。 \n          android:accessibilityFeedbackType=\"feedbackSpoken\"\n设置回馈给用户的方式\n\n          android:notificationTimeout=\"100\"\n 响应时间的设置就不用多说了 \n          android:packageNames=\"com.notrace\"\n可以指定响应某个应用的事件，我的demo包名就叫com.notrace,可以多个，用\",\"隔开。\n          android:description=\"模拟点击\"\n\n描述你在系统辅助功能开关中看到的描述\n\n3.CheckAccessbilityServices  实现onAccessibilityEvent和onInterrupt方法\n    \n    \n                    @Override  \n                public void onAccessibilityEvent(AccessibilityEvent event) {  \n                          //过滤包名\n\t\t\t\t\t\tString pkgName = event.getPackageName().toString();  \n                          if(!\"com.notrace\".equals(pkgName))\n                                return;\n                        switch (type){  \n                              case AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED:      \n                          //切换页面的时候此时会触发一个叫TYPE_WINDOW_STATE_CHANGED的事件\n                            AccessibilityNodeInfo nodeInfo = getRootInActiveWindow(); \n                           if(nodeInfo!=null)  {\n                               if(\"com.notrace.MainActivity\".equals(event.getClassName())){    \n                                    List<AccessibilityNodeInfo>     list=\n                                    nodeInfo.findAccessibilityNodeInfosByViewId(\"com.notrace:id/btn_click\");\n                              if(list!=null&&list.size()>0)  {        \n                              list.get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);       \n                               }        \n                          }       \n                           break;   \n                       case AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED:   \n                         break;\n                      }                     \n               }  \n\n\n注意这里有个叫com.notrace:id/btn_click的，就是前面的那个按钮，我取id叫btn_click,这个东西可以通过eclipse提供的一个工具dump查看,如下图：\n\n![QQ截图20160808162014.png](http://upload-images.jianshu.io/upload_images/1453857-78fa62630f5370b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n微信抢红包的界面你就可以这么看了。\nlist.get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);      就是模拟点击事件\n\n\n\n\n至此，模拟点击就已经全部完成了，我们打开手机辅助功能界面会看见：\n![QQ截图20160808162331.png](http://upload-images.jianshu.io/upload_images/1453857-2b1084259b04dab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n点击进去：\n![QQ截图20160808162434.png](http://upload-images.jianshu.io/upload_images/1453857-cd8e0447e512c2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n打开这个开关就可以了。\n至此，当页面切换到MainActivity中就可以弹出toast了，至于别的奇奇怪怪的功能，就需要小伙伴们自己摸索了。\n[Demo代码](https://github.com/messnoTrace/Demo_Accessbility.git)\n"},{"title":"android room 存储复杂数据类型","url":"/2019/04/05/android-room-存储复杂数据类型/","content":"<link href=\"http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css\" rel=\"stylesheet\">  \n<script src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\"></script>  \n<script >hljs.initHighlightingOnLoad();</script>  \n\n\n\n\n首先看此文章的都假设你已经看过了room的简单用法，如果没有看过，那你可能需要先去看看了。\n假设，我们从后台返回一个数据类型是这样的：    \n\n          public class News{\n            public long id;\n            public String title;\n            public String title;\n            public List<Tag>tags;\n          }\n\n        public class Tag{\n          public long id;\n          public String name;\n      }\n\n这种数据类型就比较很常见了，当然了，你第一反应可能是： 这个哪里复杂了，嗯，说不复杂确实不复杂，说复杂呢，是因为用room的话，确实比较麻烦，说白了，就是如何用 room存储带有lis<Object>类型的数据。ok话不多说，我们直接上代码：\n\n###bean的改造\n\n          @Entity(tableName = \"news\")\n           public class News{\n          @PrimaryKey(autoGenerate = true)\n            public long id;\n            public String title;\n            public String title;\n           @Ignore\n            public List<Tag>tags;\n          } \n\n\n           @Entity(tableName = \"tags\")\n           public class Tag{\n                 @PrimaryKey(autoGenerate = true)\n                  public long id;\n                  public String name;\n\n                   @ColumnInfo(name = \"news_id\")\n                public long newsid;\n            }\n\n\n然后我们重新添加一个bean：NewsWithTags:\n               \n\n    public class NewsWithTags{\n    @Embedded\n    public News news;\n\n      @Relation(parentColumn = \"id\",entityColumn = \"news_id\")\n       public List<Tag> tags;\n        }\n\n\n注意看这个bean，没有table注解@Embedded 注解的是news这个bean。\n@Relation 中parentColumn对应的是news中的id，entityColumn对应的是tag中的news_id,这个值实际上就等于news中的id。\n####Dao\n    NewsWithTagDao:\n\n     @Dao\n    public interface NewsWithTaDao {\n    @Transaction\n    @Query(\"SELECT * FROM news\")\n    List<NewsWithTag> getAllNews();\n\t}\n\n>其他没啥好说的，添加数据要先添加news，然后根据news 的id添加tag，删除数据，要先根据news的id删除tag表中的数据\n      \n\n\n"},{"title":"关于Unable to resolve dependency for xxCould not resolve library的解决方案","url":"/2019/04/05/关于Unable to resolve dependency for xxCould not resolve library的解决方案/","content":"先介绍下背景，环境是Androidstudio3.1.3，没错，截止目前是最新的，在不久之前，我用的是3.1.2，然后新建项目，敲上代码，implemention 各种顺手的library，毛问题都没有，升级了3.1.3之后，我想加一个库，结果出现了如下的各种问题。![WX20180626-110232.png](https://upload-images.jianshu.io/upload_images/1453857-4489eca9ee9892f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n一开始我以为是库的问题，然后一顿google搜索：\n![WX20180626-110400@2x.png](https://upload-images.jianshu.io/upload_images/1453857-b767224e5beb26ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n眼睛一亮，看到第二个答案直接出现关键词androidstudio3.0，心里顿时一阵鸡冻，点进去看看答案，直接找认同最多的答案：\n![WX20180626-110636@2x.png](https://upload-images.jianshu.io/upload_images/1453857-2d2ff13fcdfab998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n意思是啥呢，大概就是说在andoridsutio2.x向3.x迁移的时候需要注意修改的东西，然并卵啊，我是直接上的3.X的新项目，没有迁移一说。随后又是一阵搜索，这下就尴尬了，答案基本上都是类似这样 的和不勾选gradle offline work这个选项，各种搜索各种的贼鸡儿蛋疼，年轻人你感觉得到绝望么，我在想，如果时光可以倒流，我肯定不手贱升级AndroidStudio，以前的2.x用起来，是毛问题都没有啊，google都救不了我了，我怕是没救了，绝望。添加不了任何库，这个问题，是真的真的很蛋疼啊，啥都要自己写，换你，你愿意么？反正我是不愿意。。\n接着又是一波操作猛如虎，中间过程就不重要了，直接跳结果吧。\n打开Terminal选项卡，输入 ./gradlew build（windows下是gradlew build提示没这个命令的，那就是你的gradle环境变量没配置）-> 回车\n\n![WX20180626-111908.png](https://upload-images.jianshu.io/upload_images/1453857-6a68fddb44522e5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n重点来了，`Connect to 127.0.0.1:1080 [/127.0.0.1] failed: Connection refused (Connection refused)\n` mmp 搜索：\n![WX20180626-112122@2x.png](https://upload-images.jianshu.io/upload_images/1453857-e4706390e41dfdf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n第一个点进去 [链接](https://blog.csdn.net/Rainminism/article/details/79713788)\n进去一看说我们使用了代理，要修改gradle.properties 文件，然后默默的打开我们的工程此文件一看，![WX20180626-112620.png](https://upload-images.jianshu.io/upload_images/1453857-23b4e09470d702f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n意不意外，惊不惊喜，里面毛都没有啊，然后有没有人跟我一样，有点怀疑人生了，怎么办怎么办，继续搜索啊，果然，在一个答案中发现了自己是有多傻逼\n![WX20180626-113000@2x.png](https://upload-images.jianshu.io/upload_images/1453857-f646707a7e7906d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n重点来了，第一句，`Go to gradle scripts` ，卧槽，我想起来个东西，我们通常用的都是project视图啊，新建项目都是Android视图啊，要是你曾经看过Andorid视图，或者说你曾经解决过Andoridstudio遇到的坑，那你就明白了我说的是啥，吓得我赶紧切换到Android视图：\n![WX20180626-113441.png](https://upload-images.jianshu.io/upload_images/1453857-834fb634600acea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n果然，`globle properties` \n打开一看，mmp，果然存在：![WX20180626-113550.png](https://upload-images.jianshu.io/upload_images/1453857-5b2fc6c929a87506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n果断注释，重新编译，老铁，真的没毛病了。😌 mmp\n\n\n\n\n\n\n\n"},{"title":"多线程中wait/notify的一些理解，以及最经典的生产者和消费者","url":"/2019/04/05/多线程中wait-notify的一些理解，以及最经典的生产者和消费者/","content":"\n<link href=\"http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css\" rel=\"stylesheet\">  \n<script src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\"></script>  \n<script >hljs.initHighlightingOnLoad();</script>  \n\n###前言\n说到wait，很容易想到一个常问的面试题，wait和sleep的区别。简单的理解就是，wait是object的方法，调用wait()，线程会进去等待状态，并且会释放出锁，非阻塞的，等待持有锁的线程调用notify()，才会继续执行。sleep是Thread的方法，sleep()会让当前线程暂停一段时间，但是不会释放锁，是阻塞的。\n\n###Wait/notify在线程中的通信\n我们先看下面一段代码：\n class Data:\n\n            package com.notrace;\n            import java.util.ArrayList;\n            import java.util.List;\n            public class Data {\n\t    private List list=new ArrayList();\n\t      public void add() {\n\t\t    list.add(\"notrace\");\n\t    }\n\t      public int getSize() {\n\t\treturn list.size();\n\t    }\n      }\n\n\nThreadA：\n\n      package com.notrace;     \n      public class ThreadA extends Thread{\n\t private Data data;\n\t public ThreadA(Data data) {\n\t\tsuper();\n\t\tthis.data=data;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tdata.add();\n\t\t\t\tSystem.out.println(\"添加了\"+(i+1)+\"个元素\");\n\t\t\t\tThread.sleep(1000);\n\t\t\t\t\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t}\n\t}\t\n     }\n\n\nThreadB:\n\n    package com.notrace;\n    public class ThreadB extends Thread{\n\n\tprivate Data data;\n\tpublic ThreadB(Data data) {\n\t\tsuper();\n\t\tthis.data=data;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\twhile (true) {\n\t\tSystem.out.print(\"\");\n\t\t\t\tif(data.getSize()==6) {\n\t\t\t\t\tSystem.out.println(\"==6,线程B要退出了\");\n\t\t\t\t\tthrow new InterruptedException();\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n    }\n\nTest:\n\n      package com.notrace;\n    public class Test {\n\tpublic static  void  main(String []args) {\n\t\tData data=new Data();\n\t\tThreadA threadA=new ThreadA(data);\n\t\tthreadA.setName(\"A\");\n\t\tthreadA.start();\n\t\tThreadB threadB=new ThreadB(data);\n\t\tthreadB.setName(\"B\");\n\t\tthreadB.start();\n\t}\n    }\n\n运行test，结果如下：![1.png](https://upload-images.jianshu.io/upload_images/1453857-21d6e937cb766da6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n两个线程之间实现了通信，但是有一个弊端，就是线程B，要不停的循环，这样会很浪费资源，那么有没有什么好的办法去实现多个线程通信呢，答案是肯定的，就是wait/notify的机制。\n\n\n\n###wait/notify机制简单介绍\n举个栗子，就说我们日常生活中的餐厅吧，厨师和服务员之间的交互，\n厨师做完菜，放到传递台上，服务员来传递台上取，往桌上送。\n 1）厨师做完一道菜的时间是不确定的，所以把菜放到传递台上的时间也是不确定的。\n2）服务员取菜的时间，取决于厨师，所以，厨师做完菜之前，服务员，就有了等待(wait)的状态。\n3）服务员是怎么取到菜呢？这取决于厨师，简单点来说，厨师做完菜，放到传递台上，然后大喊一声：“红烧肉好了，来上菜。”然后服务员就过来取了，这个大喊一声，就相当于notify的过程。\n4）这个情景中就有wait/notify的机制了，那么如何用代码来实现呢？\n####wait/notify机制简单实现\n方法wait（）的作用是使当前执行代码的线程进行等待，wait（）方法是Object类的方法，该方法用来将当前线程置入“预执行队列”中，并且在wait（）所在的代码行处停止执行，直到接到通知或被中断为止。在调用wait（）之前，**线程必须获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait（）方法。在执行wait（）方法后，当前线程释放锁。** 在从wait（）返回前，线程与其他线程竞争重新获得锁。如果调用wait（）时没有持有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕捉异常。\n**方法notify（）也要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁。如果调用notify（）时没有持有适当的锁，也会抛出IllegalMonitorStateException。**该方法用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选出其中一个呈wait状态的线程，对其发出通知notify，并使它等待获取该对象的对象锁。需要说明的是，在执行notify（）方法后，当前线程不会马上释放该对象锁，呈wait状态的线程也并不能马上获取该对象锁，要等到执行notify（）方法的线程将程序执行完，也就是退出synchronized代码块后，当前线程才会释放锁，而呈wait状态所在的线程才可以获取该对象锁。当第一个获得了该对象锁的wait线程运行完毕以后，它会释放掉该对象锁，此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，还会继续阻塞在wait状态，直到这个对象发出一个notify或notifyAll。\n   用一句话来总结一下wait和notify：wait使线程停止运行，而notify使停止的线程继续运行。\n代码测试如下：\nThreadA:\n        \n          package com.notrace;\n\n    public class ThreadA extends Thread {\n\tprivate Object lock;\n\n\tpublic ThreadA(Object lock) {\n\t\tsuper();\n\t\tthis.lock = lock;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsynchronized (lock) {\n\t\t\t\tSystem.out.println(\"begin wait time\" +       System.currentTimeMillis());\n\t\t\t\tlock.wait();\n\t\t\t\tSystem.out.println(\"end wait time\" + System.currentTimeMillis());\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n    }\n\nThreadB:\n\n            package com.notrace;\n\n    public class ThreadB extends Thread {\n\n\tprivate Object lock;\n\n\tpublic ThreadB(Object lock) {\n\t\tsuper();\n\t\tthis.lock = lock;\n\t}\n\n\t@Override\n\tpublic void run() {\n\n\t\ttry {\n\n\t\t\tsynchronized (lock) {\n\t\t\t\tSystem.out.println(\"begin notify time:\" + System.currentTimeMillis());\n\t\t\t\tlock.notify();\n\t\t\t\tSystem.out.println(\"end nofity time:\" + System.currentTimeMillis());\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.out.println(e.toString());\n\t\t}\n\t}\n\n    }\n\nTest:\n\n            package com.notrace;\n\npublic class Test {\n\tpublic static void main(String[] args) {\n\n\t\ttry {\n\t\t\tObject lock = new Object();\n\t\t\tThreadA threadA = new ThreadA(lock);\n\t\t\tthreadA.setName(\"A\");\n\t\t\tthreadA.start();\n\n\t\t\tThread.sleep(3000);\n\t\t\tThreadB threadB = new ThreadB(lock);\n\t\t\tthreadB.setName(\"B\");\n\t\t\tthreadB.start();\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n      }\n\n运行结果如下图：\n  ![2.png](https://upload-images.jianshu.io/upload_images/1453857-070a66f33dd162b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n从打印结果来看，3S后线程别nofity唤醒.\n我们再来实现下之前的上面那个例子：\nThreadA:\n\n            package com.notrace;\n\n        public class ThreadA extends Thread {\n\tprivate Object lock;\n\n\tpublic ThreadA(Object lock) {\n\t\tsuper();\n\t\tthis.lock = lock;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t    try {\n\t        synchronized (lock) {\n\t        \tif(Data.getSize()!=6)\n\t            System.out.println(\"begin wait time\" +       System.currentTimeMillis());\n\t            lock.wait();\n\t            System.out.println(\"end wait time\" + System.currentTimeMillis());\n\t        }\n\t    } catch (Exception e) {\n\t        e.printStackTrace();\n\t    }\n\t}\n    }\n\n\nThreadB:\n\n            package com.notrace;\n      public class ThreadB extends Thread{\n\n        private Object  lock;\n      public ThreadB(Object lock) {\n        super();\n        this.lock=lock;\n    }\n\n    @Override\n    public void run() {\n        try {\n\n        synchronized (lock) {\n        \tfor (int i = 0; i < 10; i++) {\n\t\t\t\tData.add();\n\t\t\t\tif(Data.getSize()==6) {\n\t\t\t\t\tlock.notify();\n\t\t\t\t\tSystem.out.println(\"发出通知\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"添加了\"+(i+1)+\"个元素\");\n\t\t\t\tThread.sleep(1000);\n\t\t\t}        \n          \n        }\n\n    } catch (Exception e) {\n        e.printStackTrace();\n        System.out.println(e.toString());\n    }\n    }\n\n    }\n\n\nData:\n\n            package com.notrace;\n\n      import java.util.ArrayList;\n      import java.util.List;\n\n      public class Data {\n\tprivate static List list = new ArrayList();\n\n\tpublic static void add() {\n\t\tlist.add(\"notrace\");\n\t}\n\n\tpublic static int getSize() {\n\t\treturn list.size();\n\t}\n        }\n\n\nTest:\n\n          package com.notrace;\n\n        public class Test {\n\tpublic static void main(String[] args) {\n\n\t\ttry {\n\t\t\tObject lock = new Object();\n\t\t\tThreadA threadA = new ThreadA(lock);\n\t\t\tthreadA.setName(\"A\");\n\t\t\tthreadA.start();\n\n\t\t\tThread.sleep(50);\n\t\t\tThreadB threadB = new ThreadB(lock);\n\t\t\tthreadB.setName(\"B\");\n\t\t\tthreadB.start();\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\n\t}\n\n    }\n\n运行结果如下:\n![3.png](https://upload-images.jianshu.io/upload_images/1453857-584bcf34b652abb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n日志说明了一个问题,notify()调用之后，并不会立即释放锁，而是会接着执行后面的代码，执行完了，才会释放锁。\n\nsynchronized可以将任何一个Object对象作为同步对象来看待，每个Object都实现了wait()和notify()。他们必须用被用在synchronized同步的区域内，wait()让区域内的线程进入等待状态，释放同步锁，notify()可以唤醒一个因调用了wait()而处于等待状态中的线程。被唤醒的线程继续执行wait()后面的代码。如果notify之后没有处于阻塞等待中的线程，就会被忽略。\n关于释放锁，有以下几个结论，\n1）执行完同步代码块，就会释放锁。\n2）执行代码块的过程中，如果遇到异常而导致线程终止，也会释放锁。\n3）调用wait()这个线程会释放锁。\n\n另外还有一点，需要提一下。notify()只会唤醒一个线程，所以在多线程的时候，可能会出现一些问题，所以，尽量用notifyAll()唤醒所有等待的线程 比较好。下面来看看另一个经典问题。\n###生产者/消费者模式\n###一个生产者，一个消费者\n废话不多说，直接看code.\n生产者P:\n\n                package com.notrace;\n\n      //生产者\n      public class P {\n\tprivate String lock;\n\tpublic P(String lock) {\n\t\tsuper();\n\t\tthis.lock=lock;\n\t}\n\tpublic void setValue() {\n\t\ttry {\n\t\t\tsynchronized (lock) {\n\t\t\t\tif(!ValueObj.value.equals(\"\")) {\n\t\t\t\t\tlock.wait();\n\t\t\t\t}\n\t\t\t\tString value=System.currentTimeMillis()+\"\";\n\t\t\t\tSystem.out.println(\"set的值：\"+value);\n\t\t\t\tValueObj.value=value;\n\t\t\t\tlock.notify();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t}\n\t}\n    }\n\n\n消费者C:\n        \n      package com.notrace;\n\n        //消费者\n        public class C {\n\tprivate String lock;\n\tpublic C(String lock) {\n\t\tsuper();\n\t\tthis.lock=lock;\n\t}\n\tpublic void getValue() {\n\ttry {\n\t\tsynchronized (lock) {\n\t\t\tif(ValueObj.value.equals(\"\")) {\n\t\t\t\tlock.wait();\n\t\t\t}\n\t\t\tSystem.out.println(\"get的值:\"+ValueObj.value);\n\t\t\tValueObj.value=\"\";\n\t\t\tlock.notify();\n\t\t}\n\t} catch (Exception e) {\n\t\t// TODO: handle exception\n\t}\n\t}\n\n    }\n\n线程P：\n\n        package com.notrace;\n\n    public class ThreadP extends Thread{\n\n\tprivate P p;\n\tpublic ThreadP(P p) {\n\t\tsuper();\n\t\tthis.p=p;\n\t}\n\t@Override\n\tpublic void run() {\n\t\twhile(true) {\n\t\t\tp.setValue();\n\t\t}\n\t}\n    }\n线程C：\n\n                package com.notrace;\n\n      public class ThreadC extends Thread{\n\tprivate C c;\n\tpublic ThreadC(C c) {\n\t\tsuper();\n\t\tthis.c=c;\n\t}\n\t@Override\n\tpublic void run() {\n\t\twhile(true) {\n\t\t\tc.getValue();\n\t\t}\n\t}\n    }\n\n\n\nRun：\n\n              package com.notrace;\n\n    public class Run {\n\tpublic static void main(String []args) {\n\t\tString lock=new String(\"\");\n\t\tP p=new P(lock);\n\t\tC c=new C(lock);\n\t\tThreadP tP=new ThreadP(p);\n\t\tThreadC tC=new ThreadC(c);\n\t\ttP.start();\n\t\ttC.start();\n\t}\n\n    }\n\n运行结果：\n![4.png](https://upload-images.jianshu.io/upload_images/1453857-eb6739d745cb9929.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n可以看出来，是生产者，消费者，交替运行的。\n\n接下来变化一下:\n######多生产者，多消费者\n\nP:\n\n        package com.notrace;\n\n      //生产者\n      public class P {\n\tprivate String lock;\n\tpublic P(String lock) {\n\t\tsuper();\n\t\tthis.lock=lock;\n\t}\n\tpublic void setValue() {\n\t\ttry {\n\t\t\tsynchronized (lock) {\n\t\t\t\twhile(!ValueObj.value.equals(\"\")) {\n\t\t\t\t\tSystem.out.println(\"生产者:\"+Thread.currentThread().getName()+\"watting*\");\n\t\t\t\t\tlock.wait();\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"生产者:\"+Thread.currentThread().getName()+\"run*\");\n\t\t\t\tString value =System.currentTimeMillis()+\"\";\n\t\t\t\tValueObj.value=value;\n\t\t\t\tlock.notify();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t}\n\t}\n    }\n\nC:\n      \n      package com.notrace;\n\n    //消费者\n      public class C {\n\tprivate String lock;\n\tpublic C(String lock) {\n\t\tsuper();\n\t\tthis.lock=lock;\n\t}\n\tpublic void getValue() {\n\ttry {\n\t\tsynchronized (lock) {\n\t\t\twhile(ValueObj.value.equals(\"\")) {\n\t\t\t\tSystem.out.println(\"消费者:\"+Thread.currentThread().getName()+\"waitting\");\n\t\t\t\tlock.wait();\n\t\t\t}\n\t\t\tSystem.out.println(\"消费者:\"+Thread.currentThread().getName()+\"run\");\n\t\t\tSystem.out.println(\"get的值:\"+ValueObj.value);\n\t\t\tValueObj.value=\"\";\n\t\t\tlock.notify();\n\t\t}\n\t} catch (Exception e) {\n\t\t// TODO: handle exception\n\t}\n\t}\n\n    }\n\nthreadP，threadC一样:\n\nRun:\n\n            package com.notrace;\n\n      public class Run {\n\tpublic static void main(String []args) {\n\t\ttry {\n\t\t\tString lock=new String(\"\");\n\t\t\tP p=new P(lock);\n\t\t\tC c=new C(lock);\n\t\t\t\n\t\t\tThreadP[] pThreadPs=new ThreadP[2];\n\t\t\tThreadC[]cThreadCs=new ThreadC[2];\n\t\t\tfor(int i=0;i<2;i++) {\n\t\t\t\tpThreadPs[i]=new ThreadP(p);\n\t\t\t\tpThreadPs[i].setName(\"生产者\"+(i+1));\n\t\t\t\tcThreadCs[i]=new ThreadC(c);\n\t\t\t\tcThreadCs[i].setName(\"消费者\"+(i+1));\n\t\t\t\tpThreadPs[i].start();\n\t\t\t\tcThreadCs[i].start();\n\t\t\t}\n\n\t\t\tThread.sleep(5000);\t\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t}\n\t\t\n\t\t\n\t}\n\n      }\n\n\n执行完：\n![5.png](https://upload-images.jianshu.io/upload_images/1453857-c2d2686d93ecd77d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n两个都是等待，而且还没执行完，是不是很奇怪。。。产生这种情况是因为唤醒的早了点， 生产者1唤醒了生产者2，然而生产者2发现产品并未被消费，所以生产者2也是wait状态。另外，还有种原因，就是连续唤醒同类。解决这种问题，就需要将P和C中的notify改成notifyAll()，将生产者和消费者一起唤醒，就ok了。\n\n\n咱接着变\n######一生产一消费：来操作栈\n这个场景就是生产者向堆栈List中放数据，消费者从List中取数据。list最大容量是1:\np:\n\n            package com.notrace;\n\n      //生产者\n      public class P {\n\t\n\t\n\tprivate MyStack stack;\n\tpublic P(MyStack stack) {\n\t\tsuper();\n\t\tthis.stack=stack;\n\t\t\n\t}\n\tpublic void pushService() {\n\t\tstack.push();\n\t}\n    }\n\n\nC:\n  \n            package com.notrace;\n\n      //消费者\n    public class C {\n\t\n\tprivate MyStack stack;\n\tpublic C(MyStack stack) {\n\t\tsuper();\n\t\tthis.stack=stack;\n\t}\n\t\n\tpublic void popService() {\n\t\tSystem.out.println(\"pop=\"+stack.pop());\n\t}\n      }\n\n\nMyStack:\n\n\n            package com.notrace;\n\n      import java.util.ArrayList;\n      import java.util.List;\n\n      public class MyStack {\n      private List list=new ArrayList<>();\n      synchronized public void push() {\n\ttry {\n\t\tif(list.size()==1) {\n\t\t\tthis.wait();\n\t\t}\n\t\tlist.add(\"notrace:\"+Math.random());\n\t\tthis.notify();\n\t\tSystem.out.println(\"push=\"+list.size());\n\t} catch (Exception e) {\n\t\t// TODO: handle exception\n\t}\n      }\n\n          synchronized public String pop() {\n\tString value=\"\";\n\ttry {\n\t\tif(list.size()==0) {\n\t\t\tSystem.out.println(\"pop操作\"+Thread.currentThread().getName());\n\t\t\tthis.wait();\n\t\t}\n\t\tvalue=\"\"+list.get(0);\n\t\tlist.remove(0);\n\t\tthis.notify();\n\t\tSystem.out.println(\"pop\"+list.size());\n\t} catch (Exception e) {\n\t\t// TODO: handle exception\n\t}\n\treturn value;\n      }\n    }\n\n\nThreadP:\n\n            package com.notrace;\n\n      public class ThreadP extends Thread{\n\n\tprivate P p;\n\tpublic ThreadP(P p) {\n\t\tsuper();\n\t\tthis.p=p;\n\t}\n\t@Override\n\tpublic void run() {\n\t\twhile(true) {\n\t\t\tSystem.out.print(\"\");\n\t\t\tp.pushService();\n    //\t\t\tp.setValue();\n\t\t\t\n\t\t}\n\t}\n    }\n\n\nThreadC:\n\n            package com.notrace;\n\n    public class ThreadC extends Thread{\n\tprivate C c;\n\tpublic ThreadC(C c) {\n\t\tsuper();\n\t\tthis.c=c;\n\t}\n\t@Override\n\tpublic void run() {\n\t\twhile(true) {\n\t\t\tSystem.out.print(\"\");\n\t\t\tc.popService();\n      //\t\t\tc.getValue();\n\t\t}\n\t}\n      }\n\nRun:\n\n            package com.notrace;\n\npublic class Run {\n\tpublic static void main(String []args) {\n\t\t\n\t\t\n\t\tMyStack stack=new MyStack();\n\t\tP p=new P(stack);\n\t\tC c=new C(stack);\n\t\tThreadP threadP=new ThreadP(p);\n\t\tThreadC threadC=new ThreadC(c);\n\t\tthreadP.start();\n\t\tthreadC.start();\n    }\n    }\n\n执行结果：\n![6.png](https://upload-images.jianshu.io/upload_images/1453857-eb44c5bbfbef7611.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n程序的结果是size不会大于1|。\n\n###一生产多消费：来操作栈\n代码还是上面的那些，我们改一下Run：\n            \n            package com.notrace;\n\n    public class Run {\n\tpublic static void main(String []args) {\n\t\t\n\t\t\n\t\tMyStack stack=new MyStack();\n\t\tP p=new P(stack);\n\t\tC c1=new C(stack);\n\t\tC c2=new C(stack);\n\t\tC c3=new C(stack);\n\t\tC c4=new C(stack);\n\t\tC c5=new C(stack);\n\t\tThreadP threadP=new ThreadP(p);\n\t\tThreadC threadC1=new ThreadC(c1);\n\t\tThreadC threadC2=new ThreadC(c2);\n\t\tThreadC threadC3=new ThreadC(c3);\n\t\tThreadC threadC4=new ThreadC(c4);\n\t\tThreadC threadC5=new ThreadC(c5);\n\t\tthreadP.start();\n\t\tthreadC1.start();\n\t\tthreadC2.start();\n\t\tthreadC3.start();\n\t\tthreadC4.start();\n\t\tthreadC5.start();\n      }\n      }\n执行结果：![7.png](https://upload-images.jianshu.io/upload_images/1453857-e4a1b50023c36141.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n假死状态了，多次执行。还可能会出现indexoutofbounce，这是因为条件改变时并没有得到及时的响应，引起了list.remove(0)报错，解决办法是将MyStack中的if()判断改为while()。多消费一生产，多消费多生产，也是一样的。改一下run里面的代码就行了\n\n好了，基本完事。\n\n\n\n  \n\n\n\n\n\n  \n\n\n\n                \n\n\n\n"},{"title":"用androidstudio编写第一个xposed模块","url":"/2019/04/05/用androidstudio编写第一个xposed模块/","content":"<link href=\"http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css\" rel=\"stylesheet\">  \n<script src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\"></script>  \n<script >hljs.initHighlightingOnLoad();</script>  \n前提：你的手机装了xposedinstaller ，已经获取root权限，否则以下内容不用看了。\n参考链接:https://blog.csdn.net/mrglaucusss/article/details/50963542\n\n####配置准备工作\n我的as版本是3.1的。所以基于此版本做操作\n* 新建一个工程包名随便取。我取了com.notrace\n* MainActivity代码简单如下:\n            \n                package com.notrace;\n          import android.support.v7.app.AppCompatActivity;\n        import android.os.Bundle;\n        import android.view.View;\n        import android.widget.Toast;\n\n        public class MainActivity extends AppCompatActivity {\n\n        @Override\n          protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_main);\n            findViewById(R.id.buttonPanel).setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                Toast.makeText(MainActivity.this,hook(),Toast.LENGTH_SHORT).show();\n                }\n            });\n        }\n    \n        public String hook(){\n        return \"未被劫持\";\n        }\n      }\n\n很简单，一个button点击弹出toast，显示hook函数返回值,我的目标就是修改这个hook的返回值\n\n* 修改清单文件，在application节点下添加\n\n                      <meta-data\n            android:name=\"xposedmodule\"\n            android:value=\"true\" />\n        <meta-data\n            android:name=\"xposeddescription\"\n            android:value=\"你猜猜\" />\n        <meta-data\n            android:name=\"xposedminversion\"\n            android:value=\"54\" />\n\n\n第一个表示是否是xposed模块\n第二个是描述，随便你写\n第三个是最低的api版本支持\n\n* 修改app/gradle\n\n              repositories {\n            jcenter()\n        }\n        dependencies {\n          compileOnly 'de.robv.android.xposed:api:82'\n          compileOnly 'de.robv.android.xposed:api:82:sources'\n          implementation 'com.android.support:appcompat-v7:27.1.1'\n          implementation 'com.android.support.constraint:constraint-layout:1.1.0'\n          testImplementation 'junit:junit:4.12'\n          androidTestImplementation 'com.android.support.test:runner:1.0.2'\n          androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'\n  \n        }\n\n注意，上面两个一定要修改为compileOnly 如果你是低版本的as可以改成provided \n\n\n#####代码\n* 新建HookTest 类：\n\n\n              package com.notrace;\n\n            import de.robv.android.xposed.IXposedHookLoadPackage;\n            import de.robv.android.xposed.XC_MethodHook;\n            import de.robv.android.xposed.XposedBridge;\n          import de.robv.android.xposed.XposedHelpers;\n          import de.robv.android.xposed.callbacks.XC_LoadPackage;\n\n          public class HookTest implements IXposedHookLoadPackage {\n              @Override\n              public void handleLoadPackage(XC_LoadPackage.LoadPackageParam loadPackageParam)           throws Throwable {\n\n\n        if(loadPackageParam.packageName.equals(\"com.notrace\")){\n            XposedBridge.log(\"NOTRACE\"+loadPackageParam.packageName);\n\n            Class clazz=loadPackageParam.classLoader.loadClass(\"com.notrace.MainActivity\");\n\n            XposedHelpers.findAndHookMethod(clazz, \"hook\", new XC_MethodHook() {\n                @Override\n                protected void beforeHookedMethod(MethodHookParam param) throws Throwable {\n                    super.beforeHookedMethod(param);\n                }\n\n                @Override\n                protected void afterHookedMethod(MethodHookParam param) throws Throwable {\n                    param.setResult(\"你已经被劫持了\");\n                }\n            });\n        }\n    }\n      }\n\n* 添加xposed入口，新建assets：![微信截图_20180511182235.png](https://upload-images.jianshu.io/upload_images/1453857-7f9d3d644e31ea0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nxposed_init内容如下：\n\n          com.notrace.HookTest\n        \n\n* 至此结束，然后如果你没有禁用instant run 那么你就得打一个带签名的安装包，然后安装到手机上，然后再xposed installer模块中勾选你编写的module，然后手机重启生效。\n\n\n\n\n\n\n"},{"title":"Android如何在子module中取获取主module中通过网络接口请求返回的数据？","url":"/2019/04/05/Android如何在子module中取获取主module中通过网络接口请求返回的数据？/","content":"<link href=\"http://cdn.bootcss.com/highlight.js/8.0/styles/monokai_sublime.min.css\" rel=\"stylesheet\">  \n<script src=\"http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js\"></script>  \n<script >hljs.initHighlightingOnLoad();</script>  \n如题：今天遇到一个需求，在子module中获取主module中通过网络接口异步返回的数据？嗯。。绕了一下午把自己绕进去了，简单来说，就两个回调完事。一个request，一个response。但是胡思乱想了一下午，很是尴尬，废话不多说，咱直接上代码。\n###首先一个request接口：\n            public interface IRequest {\n    public void request(IResponse response);\n      }\n\n###然后一个response接口\n\n            public interface IResponse {\n    void response(String result);\n      }\n\n###一个通信管理\n            public class BridgeManager {\n    private IRequest request;\n\n    public void registerCallback(IRequest request) {\n        this.request = request;\n    }\n\n    public IRequest getRequest() {\n        return request;\n    }\n\n    public void setRequest(IRequest request) {\n        this.request = request;\n    }\n    }\n###为了方便扩展，我们再来一个通信管理的list的管理容器\n            public class BrigeListManager {\n    private static class SingletonHolder {\n\n        private static final BrigeListManager sInstance = new BrigeListManager();\n    }\n\n    public static BrigeListManager getInstance() {\n        return SingletonHolder.sInstance;\n    }\n\n    private BridgeManager bridgeManager;\n\n    public BridgeManager getBridgeManager() {\n        return bridgeManager;\n    }\n\n    public void setBridgeManager(BridgeManager bridgeManager) {\n        this.bridgeManager = bridgeManager;\n    }\n     }\n\n###   我们再来写一个主工程模拟网络请求的东东\n\n          public class MainModuleImpl extends BridgeManager{\n    public MainModuleImpl(){\n\n        registerCallback(new IRequest() {\n            @Override\n            public void request(IResponse response) {\n\n                try {\n                    Thread.sleep(3000);\n\n                    System.out.print(\"耗时任务执行完毕\");\n                    response.response(\"给子module返回结果\");\n                }catch (Exception e){\n\n                }\n            }\n        });\n    }\n       }\n\n\n###  然后随便在写一个主工程中初始化的地方,具体情况具体考察，我只模拟一下下\n            public class MainModule {\n    MainModule(){\n        BrigeListManager.getInstance().setBridgeManager(new MainModuleImpl());\n    }\n     }\n\n\n### 完事了，我们模拟一下子module中如何获取\n\n              public class Test {\n    public static void main(String args[]) {\n\n\n        MainModule mainModule=new MainModule();\n        IResponse response = new IResponse() {\n            @Override\n            public void response(String result) {\n                System.out.print(result);\n            }\n        };\n        BrigeListManager.getInstance().getBridgeManager().getRequest().request(response);\n\n    }\n       }\n\n\n###### end\n\n   ![WX20181129-212144@2x.png](https://upload-images.jianshu.io/upload_images/1453857-b084f81966313e54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n嗯，，，美滋滋吧，虽说代码不难，但是不知道为什么，却让我想的很是难受，恼火，可能年纪大了，😔\n \n\n\n"},{"title":"资源索引","url":"/2019/04/05/资源索引/","content":"### hexo 使用教程\n[hexo教程:基本配置+更换主题+多终端工作+coding page部署分流(2)]([http://fangzh.top/2018/2018090715/](http://fangzh.top/2018/2018090715/)\n)\n [我是如何利用Github Pages搭建起我的博客，细数一路的坑](https://www.cnblogs.com/jackyroc/p/7681938.html)\n[hexo-theme-aircloud主题](https://github.com/aircloud/hexo-theme-aircloud)\n\n\n"}]